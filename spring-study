1,Spring 在setConfigLocation() 中调用getEnvironment()的createEnvironment()方法创建了两个PropertySource对象 
SystemEnvironmentPropertySource(系统环境变量PATH）  SystemPropertySource（JAVA运行变量）可以通过VMOPTIONS -D来设置具体属性与值.
另外还创建了PropertySourceResolver设置存储PropertySources 并且设置一些属性来方便解析
2,initPropertySource()  来做自己的拓展  比如 setRequiredProeprty(属性值)  可以再后面的valiatedRequiredProperty检验。如果不存在就会抛出异常.
3,初始化xmlDefinaitionReader  设置reader的 DTD方式解析器 BeansDtdResolver  XSD方式解析器 PluggableSchemaResolver meta/spring.schemas存有XSD的名字
4,load 将XML转化为xmlBeanDefinaition
5, 配置文件路径由String --------->String []----------------->Resource[]-------------------------->Resource  
6,xmlDefinaitionReader 采用SAX解析把xml对象先转化为Document对象 对于beans下已有的element做符合自身XSD的处理，
对于自定义element,先根据element.getNamespaceUri方法获取此标签的namespace名称,再根据namespaceUri  到spring.handler文件中找到对应的namespaceHandler
7,找到此element的namespaceHandler后,反射实例化Handler 根据elmentName在Handler里面找到对应的parser
8,根据属性parser将属性和属性值,Class类型转化为对应的BeanDefinition

1.2自定义属性编辑器
1.2.1 首先要有一个自定义属性编辑器,将xml中的propertyValue 按照一定规则转化为相应的对象.
1.2.2 要在属性赋值时调用自定义属性编辑器，填充转换后的属性值.这一步在BeanWrapper当中，所以要将属性编辑器移动到BW当中
1.2.3 为了找到对应的属性的属性编辑器需要CLASS以及PropertyEditor 所以需要PropertyEditorRegistar将两者注入到一个Map当中去
1.2.3 要将属性编辑器移动到BeanWrapper当中，只能先放入BeanFactory.
1.2.4 要将属性编辑器移动到BeanFactory当中，利用BeanFactoryProcessor 在实例化Bean之前做好这些操作，方便实例化，初始化填充属性调用。
1.2.5 Spring 提供了一个CustomConfigureEditor将属性编辑器移动到BeanFactory当中去.所以要先将PropertyEditorRegistar注册到CustomConfigureEditor
或者直接将Class,PropertyEditor放入CustomConfigureEditor里的Map.



2.BeanFacoryPostProcessor(BFP)  BeanFactoryRegistryPostProcessor(BRP)的执行顺序。
2.1 初始化两个容器 一个存在BFP 一个存放BRP  registryBeanFactoryProcessors   regularBeanFactoryProcessors
2.2 存放外部自定义的所有BFP 存放外部自定义的BRP 并且执行BRP自身的实现方法
2.3 获取内部所有的BRP且优先级为PritorOrder的  存放所有的BRP并且执行BRP自身的实现方法。
2.4 获取内部所有的BRP且优先级为Order的的  存放所有的BRP并且执行BRP自身的实现方法.
2.5 循环获取(防止在调用BRP实现方法的同时，注册进来新的BRP!)所有剩下的BRP 存放所有的BRP 并且执行BRP自身的实现方法。
2.6 执行所有BRP从BFP继承的实现方法
2.7 执行外部所有BFP的实现方法
2.9 初始化三个容器 一个存放PO BFP  一个存放OR  BFP  一个存放普通BFP
2.10 获取内部所有的BFP且优先级为PritoryOrder的 存放所有的BFP(如果在之前执行BRP是就已经执行过，这不进行获取执行)
2.11 获取内部所有的BFP且优先级为Order的 存放所有的BFP(如果在之前执行BRP是就已经执行过，这不进行获取执行)
2.12 获取内部所有的BFP且优先级为普通的 存放所有的BFP(如果在之前执行BRP是就已经执行过，这不进行获取执行)
2.12 一次执行内部所有的BFP的实现方法 结束.

3,ConfigurePostBeanProcessor的加载（重点）  
3.1 配置文件<context:componentScan>标签 会解析basePackages属性 获取扫描包的路径  
3.2 将包下面的类转化为ScanAnnotationBeanDefinition 并且加入BeanDefinitionMap当中去,并且将一些Spring内部的InnerBean自动添加ConfigurationClassPostProcessor，AutowiredAnnotationBeanPostProcessor等等
3.3 后续执行外部BRP的实现方法时，会执行 ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry方法，进一步执行processConfigBeanDefinitions方法
3.4 processConfigBeanDefinitions方法 会调用ConfigurationClassParser的parse方法对所有的Sbd进行parse();
3.5 parse()方法 doProcessConfigurationClass()方法
3.6 doProcessConfigurationClass() 先判断是否是@Component注解(@Configuration注解组合注解包含了@Component)
3.7 如果是，则processMemberClasses() 继续扫描带有配置注解的内部类
3.8 获取所有带有注解的内部类  再次调用processConfigurationClass（）方法(递归可以解析所有注解修饰的内部类)
3.9 判断是否是@PropertySource注解修饰修饰的类
3.10 如果是加载相应的Properties文件
3.11 判断是否是@ComponentScan注解修饰的类，
3.12 如果是 加载 @ComponentScan  basePackages里面的所有注解修饰的配置类到BeanFactory中去 然后再次调用processConfigBeanDefinitions方法递归解析所有注解配置类
3.13 判断是否是@Import注解修饰的类，
3.14 初始化一个访问过的所有类的集合，初始化一个存放@Import value里面的类
3.15 collectImport()递归调用，最终达到遍历所有注解的效果.
3.16 processImports()处理得到的@Import value里的类
3.17 判断是否@Import value里的类是否实现了ImportSelector接口
3.18 如果是 继续判断是否实现了deferredImportSelector接口，如果是将其添加到deferredImportSelector的集合当中去  
3.19 之后将DeferredImportSelector的元素 进行process方法 deferredImportSelectorHandler.process() 
3.20 将DeferedImportSelector里的元素包装成group对象再调用它的getImports()方法
3.21 getImport()方法中会调用@DeferredImportSelector的process()方法,比如：springboot 当中@AutoConfigurationImportSelector的解析  
3.22 AutoConfigurationImportSelector的process()方法会加载spring.factories文件,将文件中的一堆配置类的相关信息加载进来 ()  



3.3如果实现了ImportRegistar接口的话，之后再processImport之后会通过该

```java 
this.reader.loadBeanDefinitions(configClasses);
//=====================================
public void loadBeanDefinitions(Set<ConfigurationClass> configurationModel) {
		TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator();
		for (ConfigurationClass configClass : configurationModel) {
			loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);
		}
	}
//=======================================================
	private void loadBeanDefinitionsForConfigurationClass(
			ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) {

		if (trackedConditionEvaluator.shouldSkip(configClass)) {
			String beanName = configClass.getBeanName();
			if (StringUtils.hasLength(beanName) && this.registry.containsBeanDefinition(beanName)) {
				this.registry.removeBeanDefinition(beanName);
			}
			this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());
			return;
		}

		if (configClass.isImported()) {
			registerBeanDefinitionForImportedConfigurationClass(configClass);
		}
		for (BeanMethod beanMethod : configClass.getBeanMethods()) {
			loadBeanDefinitionsForBeanMethod(beanMethod);
		}

		loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());
		loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());
	}
//==============================================================================
private void loadBeanDefinitionsFromRegistrars(Map<ImportBeanDefinitionRegistrar, AnnotationMetadata> registrars) {
		registrars.forEach((registrar, metadata) ->
				registrar.registerBeanDefinitions(metadata, this.registry, this.importBeanNameGenerator));
	}
```




4.ApplicationListener 事件监听器  
```java

//方法初始化一个事件多播器,
initApplicationEventMulticaster();
//此多播器继承AbstractApplicationEventMulticaster
this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
//内部类存在一个存放监听器的集合
private final DefaultListenerRetriever defaultRetriever = new DefaultListenerRetriever();
//存放监听器的集合
public final Set<ApplicationListener<?>> applicationListeners = new LinkedHashSet<>();
//存放监听器名称的集合
public final Set<String> applicationListenerBeans = new LinkedHashSet<>();
//注册监听器,进各类监听器放入BeanFactory当中去
registerListeners();
//监听器在spring-boot当中的应用
//实例化spring.factories的13个监听器
SpringApplicationRunListeners listeners = getRunListeners(args);
//spring.factories当中有13个监听器,其中一个监听器的构造器初始化多播器
public EventPublishingRunListener(SpringApplication application, String[] args) {
		this.application = application;
		this.args = args;
		this.initialMulticaster = new SimpleApplicationEventMulticaster();
		for (ApplicationListener<?> listener : application.getListeners()) {
			this.initialMulticaster.addApplicationListener(listener);
		}
	}
this.initialMulticaster.multicastEvent(new ApplicationStartedEvent(this.application, this.args));
//根据事件类型,选择对应的监听器,让监听器执行相应的操作
	public void multicastEvent(final ApplicationEvent event, ResolvableType eventType) {
		ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
		for (final ApplicationListener<?> listener : getApplicationListeners(event, type)) {
			Executor executor = getTaskExecutor();
			if (executor != null) {
				executor.execute(new Runnable() {
					@Override
					public void run() {
						invokeListener(listener, event);
					}
				});
			}
			else {
				invokeListener(listener, event);
			}
		}
	}

```





5.Spring Conversionservice

```
PlaceholderConfigurerSupport 继承PropertiesLoaderSupport 实现BeanFactoryPostProcessor
StringValueResolver valueResolver = new PlaceholderResolvingStringValueResolver(props);
doProcessProperties(beanFactoryToProcess, valueResolver);

doProcessProperties方法 beanFactoryToProcess.addEmbeddedValueResolver(valueResolver);//将valueResorlver加入到beanFactory的embeddedValueResolvers属性当中去


	//如果之前没有StringvalueResolver,则自动注入一个StringValueResolver
		if (!beanFactory.hasEmbeddedValueResolver()) {
			beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal));
		}
		
```

```xml
<bean id="conversionservice" class="org.springframework.context.support.ConversionServiceFactoryBean">
    <property name="converters">   
    <set>
        <bean class="com.springsource.custom.WzyConverter"/>
     </set>
    </property>
</bean>
```



## 6.spring FactoryBean的注入

1，如果要创建在SringBean生命周期之外的Bean 可以创建 一个实现FactoryBean接口的实现类工厂，利用里面的getObject()  getType()  isSingleTonBean() 方法返回自定义Bean.

2，applicationContext启动过程中只会实例化FactoryBean接口的实现类放入一级工厂，只有调用getBean(“自定义工厂Name”)方法时才会真正返回getObject()创建的对象。如果调用getBean(“&自定义工厂Name”)方法，则会返回此自定义工厂对象.里面有判断如下：

```java//判断名称是否含有&前缀if (BeanFactoryUtils.isFactoryDereference(name)) {  
if (beanInstance instanceof NullBean) {     
return beanInstance; 
}
}
return (name != null && name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));```
```

3, 一级缓存里会存放实现FactoryBean接口的自定义工厂Bean,而如果是单例模式的话factoryBeanObjectCache

会存放getObject()创建出的自定义Bean.如果不是单例模式的话则会重新调用实现FactoryBean接口的实现类的getObject()方法创建新Bean对象。

```java	if (mbd != null) {
if (factory.isSingleton() && containsSingleton(beanName)) {
    synchronized (getSingletonMutex()) {
        //尝试从factoryBeanObjectCache获取，如果不存在返回getObject并且添加到factoryBeanObjectCache，存在则返回。适用于单例模式
        Object object = this.factoryBeanObjectCache.get(beanName);
        if (object == null) {
            //返回实现FactoryBean接口的getObject对象
            object = doGetObjectFromFactoryBean(factory, beanName);
            // Only post-process and store if not put there already during getObject() call above
            // (e.g. because of circular reference processing triggered by custom getBean calls)
            Object alreadyThere = this.factoryBeanObjectCache.get(beanName);
            if (alreadyThere != null) {
                object = alreadyThere;
            }
            else {
                if (shouldPostProcess) {
                    if (isSingletonCurrentlyInCreation(beanName)) {
                        // Temporarily return non-post-processed object, not storing it yet..
                        return object;
                    }
                    beforeSingletonCreation(beanName);
                    try {
                        object = postProcessObjectFromFactoryBean(object, beanName);
                    }
                    catch (Throwable ex) {
                        throw new BeanCreationException(beanName,
                                                        "Post-processing of FactoryBean's singleton object failed", ex);
                    }
                    finally {
                        afterSingletonCreation(beanName);
                    }
                }
                if (containsSingleton(beanName)) {
                    this.factoryBeanObjectCache.put(beanName, object);
                }
            }
        }
        return object;
    }
}
else {
    //非单例BeanFactory创建的Bean
    Object object = doGetObjectFromFactoryBean(factory, beanName);
    if (shouldPostProcess) {
        try {
            object = postProcessObjectFromFactoryBean(object, beanName);
        }
        catch (Throwable ex) {
            throw new BeanCreationException(beanName, "Post-processing of FactoryBean's object failed", ex);
        }
    }
    return object;
}

​```
```





## 7.Spring lookupmethod标签的使用与解析原理

#### 7.1使用 

```xml	<bean id="cat1" class="com.springsource.lookupmethodstudy.Cat">
​```xml
	<bean id="cat1" class="com.springsource.lookupmethodstudy.Cat">
	</bean>

	<bean id="dog1" class="com.springsource.lookupmethodstudy.Dog">
	</bean>

	<bean id="animal1" class="com.springsource.lookupmethodstudy.Animal">
		<lookup-method bean="cat1" name="getAnimal"></lookup-method>
	</bean>
​```
```



#### 7.2解析



##### 7.2.1 首先，如果该Bean标签含有lookup-method标签，那么会设定此Bean的一个标志位位false方便实例化时获取

```java 
mbdToUse.prepareMethodOverrides();
//===================================================================================
if (hasMethodOverrides()) {
			getMethodOverrides().getOverrides().forEach(this::prepareMethodOverride);
		}
//===================================================================================
	int count = ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName());
		if (count == 0) {
			throw new BeanDefinitionValidationException(
					"Invalid method override: no method with name '" + mo.getMethodName() +
					"' on class [" + getBeanClassName() + "]");
		}
		else if (count == 1) {
			//设置标志位，避免之后的判断，为下文做铺垫
			// Mark override as not overloaded, to avoid the overhead of arg type checking.
			mo.setOverloaded(false);
		}
```



##### 7.2.2 设定过标志位后，下文实例化此Bean 会判断标志位如果设定过标志位则采用CgLib策略模式生成此Bean



```java 
if (!bd.hasMethodOverrides()) {

}
else {
			// Must generate CGLIB subclass.
			return instantiateWithMethodInjection(bd, beanName, owner);
		}
//===================================================================================

return new CglibSubclassCreator(bd, owner).instantiate(ctor, args);

//===================================================================================
		//CgLib为此BeanDefinition生成一个子类
			Class<?> subclass = createEnhancedSubclass(this.beanDefinition);
			Object instance;
			if (ctor == null) {
				instance = BeanUtils.instantiateClass(subclass);
			}
			else {
				try {
					Constructor<?> enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());
					instance = enhancedSubclassConstructor.newInstance(args);
				}
				catch (Exception ex) {
					throw new BeanInstantiationException(this.beanDefinition.getBeanClass(),
							"Failed to invoke constructor for CGLIB enhanced subclass [" + subclass.getName() + "]", ex);
				}
			}
			// SPR-10785: set callbacks directly on the instance instead of in the
			// enhanced class (via the Enhancer) in order to avoid memory leaks.
			Factory factory = (Factory) instance;
			//在Callbacks里面设置lookupOverride拦截器
			factory.setCallbacks(new Callback[] {NoOp.INSTANCE,
					new LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),
					new ReplaceOverrideMethodInterceptor(this.beanDefinition, this.owner)});
			return instance;
```



##### 7.2.3 此时BeanFactory当中存放的是两个CGLib生成的目标类的子类对象。当使用此对象调用它的重写方法时,CGlib的lookupmethod  Interceptor就会生效.

```java 
	public Object intercept(Object obj, Method method, Object[] args, MethodProxy mp) throws Throwable {
			// Cast is safe, as CallbackFilter filters are used selectively.
			LookupOverride lo = (LookupOverride) getBeanDefinition().getMethodOverrides().getOverride(method);
			Assert.state(lo != null, "LookupOverride not found");
			Object[] argsToUse = (args.length > 0 ? args : null);  // if no-arg, don't insist on args at all
			if (StringUtils.hasText(lo.getBeanName())) {
				Object bean = (argsToUse != null ? this.owner.getBean(lo.getBeanName(), argsToUse) :
						this.owner.getBean(lo.getBeanName()));
				// Detect package-protected NullBean instance through equals(null) check
				return (bean.equals(null) ? null : bean);
			}
			else {
				return (argsToUse != null ? this.owner.getBean(method.getReturnType(), argsToUse) :
						this.owner.getBean(method.getReturnType()));
			}
		}
	}
```



##### 7.2.4 为什么要使用lookup-method标签，解决了什么问题？

1. lookup-method标签解决了单例模式的对象 引用多例的问题

2. 如果引用对象是多例模式的话,单例对象的引用，会因为单例对象一直存在于缓存中，而导致每次获取的引用也是第一次创建的引用对象。

3. 如果采用lookup-method的话则解决此问题，lookupMethodInteceptor 会在获取此引用对象时(getBean()方法)判断此对象的创建模式，如果是多例模式的话，那么就会调用多例模式的创建方法，生成一个全新的对象.

```xml 
	<bean id="cat1" class="com.springsource.lookupmethodstudy.Cat" scope="singleton">
	</bean>

	<bean id="dog1" class="com.springsource.lookupmethodstudy.Dog" scope="prototype">
	</bean>

	<bean id="catOrDog1" class="com.springsource.lookupmethodstudy.CatOrDog">
		<lookup-method bean="cat1" name="getAnimal"></lookup-method>
	</bean>

	<bean id="catOrDog2" class="com.springsource.lookupmethodstudy.CatOrDog" >
		<lookup-method bean="dog1" name="getAnimal" ></lookup-method>
	</bean>


	<bean id="refDog" class="com.springsource.lookupmethodstudy.RefDog" >
		<property name="animal" ref="dog1"></property>
	</bean>


```

```java 
//多例模式的创建
else if (mbd.isPrototype()) {
					// It's a prototype -> create a new instance.
					Object prototypeInstance = null;
					try {
						beforePrototypeCreation(beanName);
						prototypeInstance = createBean(beanName, mbd, args);
					}
					finally {
						afterPrototypeCreation(beanName);
					}
					beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
				}
```





###8.Supplier创建Bean

1. 如果一个beanDefintion设置了instanceSupplier属性的话，那么就会根据实现此supplier的lambda表达式创建bean

	```java 
	Supplier<?> instanceSupplier = mbd.getInstanceSupplier();
			if (instanceSupplier != null) {
				return obtainFromSupplier(instanceSupplier, beanName);
			}
	\\=======================================================================
		protected BeanWrapper obtainFromSupplier(Supplier<?> instanceSupplier, String beanName) {
			Object instance;
	
			String outerBean = this.currentlyCreatedBean.get();
			this.currentlyCreatedBean.set(beanName);
			try {
				//调用实现supplier接口的get方法
				instance = instanceSupplier.get();
			}
			finally {
				if (outerBean != null) {
					this.currentlyCreatedBean.set(outerBean);
				}
				else {
					this.currentlyCreatedBean.remove();
				}
			}
	
			if (instance == null) {
				instance = new NullBean();
			}
			//创建此对象的包装类
			BeanWrapper bw = new BeanWrapperImpl(instance);
			//初始化此对象，填充属性
			initBeanWrapper(bw);
			return bw;
		}
	```

	

	

2. 可以通过BFPP 来给BeanDefinition来设置instanceSupplier属性

	```java  
	public class WzyBeanFactoryProcessor implements BeanFactoryPostProcessor {
		@Override
		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
			BeanDefinition beanDefinition=beanFactory.getBeanDefinition("wzySupplierBean");
			GenericBeanDefinition gbd=(GenericBeanDefinition)beanDefinition;
			gbd.setInstanceSupplier(WzySupplierBean::get);
		}
	}
	```

	```xml  
		<bean id="wzyBeanFactoryProcessor" class="com.springsource.suppliesstudy.WzyBeanFactoryProcessor" >
		</bean>
	
		<bean id="wzySupplierBean" class="com.springsource.suppliesstudy.WzySupplierBean" ></bean>
	```

	

### 9.InstantiationAwareBeanPostProcessor 创建Bean

1. 如果此工厂中含有 **InstantiationAwareBeanPostProcessor**  的话 那么会先执行他的postProcessBeforeInstantiation来实例化相应的Bean.在通过**BeanPostProcessor的postProcessAfterInitialization**初始化

	```java  
	// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
				//如果工厂中含有InstantiationAwareBeanPostProcessor的话,那么会用他的beforepost方法来实例化相应的Bean
				Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
				if (bean != null) {
					return bean;
				}
	//=====================================================================
		protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {
			Object bean = null;
			if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {
				// Make sure bean class is actually resolved at this point.
				if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
					Class<?> targetType = determineTargetType(beanName, mbd);
					if (targetType != null) {
						bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);
						if (bean != null) {
							bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);
						}
					}
				}
				mbd.beforeInstantiationResolved = (bean != null);
			}
			return bean;
		}
	\\==============================================================================
	    	protected Object applyBeanPostProcessorsBeforeInstantiation(Class<?> beanClass, String beanName) {
			for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {
				Object result = bp.postProcessBeforeInstantiation(beanClass, beanName);
				if (result != null) {
					return result;
				}
			}
			return null;
		}
	\\===============================================================================
	    	public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
				throws BeansException {
	
			Object result = existingBean;
			for (BeanPostProcessor processor : getBeanPostProcessors()) {
				Object current = processor.postProcessAfterInitialization(result, beanName);
				if (current == null) {
					return result;
				}
				result = current;
			}
			return result;
		}
	```

	2. 所以可以通过定义**InstantiationAwareBeanPostProcessor**  重写对应的方法 来创建相应的Bean

		```xml  
		<bean id="wzyInstantiationBeanPostProcessor" class="com.springsource.beanpostprocessor.WzyInstantiationBeanPostProcessor" >
			</bean>

			<bean id="personPost" class="com.springsource.beanpostprocessor.Person" >
			</bean>
		```
		



```java  
	public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {
		if(beanClass==Person.class) {
			System.out.println("调用WzyInstantiationBeanPostProcessor  BeforeInstantiation方法");
			Enhancer enhancer=new Enhancer();
			return new Person(1, "小龙女");
		}
		return null;
	}

	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("调用WzyInstantiationBeanPostProcessor  AfterInstantiation方法");
		if(bean instanceof  Person){
			Person person=(Person) bean;
			person.setName("黄蓉");
			person.setId(2);
			return person;
		}
		return null;
	}
```





### 10. 静态工厂创建Bean/实例工厂创建Bean

1. 如果一个BeanDefinition的factory-Method属性不为空的话，那么就采用这种方式创建Bean

	```java  
		//判断此BeanDefinition的factoryMethod属性，如果有的话采用FactoryMethod的形式来创建对象
			if (mbd.getFactoryMethodName() != null) {
				return instantiateUsingFactoryMethod(beanName, mbd, args);
			}
	\\================================================================================
	    	protected BeanWrapper instantiateUsingFactoryMethod(
				String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {
	
			return new ConstructorResolver(this).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);
		}
	
	\\================================================================================
	    
	```

2. 创建工厂Bean钰指定工厂创建指定Bean.

	```java 
	public class WzyStaticBeanFactory {
		public static Person createPerson(int args1,String args2){
			return new Person(args1,args2);
		}
	
	
		public static Person createPerson(int args1){
			return new Person(args1);
		}
	}
	
		public  Person createPerson(int args1,String args2){
			return new Person(args1,args2);
		}
	
		public  Person createPerson(int args1){
			return new Person(args1);
		}
	```

	```xml  
		<bean id="staticFactory-person1" class="com.springsource.factorymethodstudy.WzyStaticBeanFactory" factory-method="createPerson" scope="prototype">
			<constructor-arg value="10"></constructor-arg>
			<constructor-arg value="staticBeanPerson"></constructor-arg>
		</bean>
	
		<bean id="staticFactory-person2" class="com.springsource.factorymethodstudy.WzyStaticBeanFactory" factory-method="createPerson" scope="singleton">
			<constructor-arg value="11"></constructor-arg>
		</bean>
	
		<bean id="wzyInstanceBeanFactory" class="com.springsource.factorymethodstudy.WzyInstanceBeanFactory" >
		</bean>
		<bean id="instanceFactory-person1" class="com.springsource.factorymethodstudy.Person" factory-bean="wzyInstanceBeanFactory" factory-method="createPerson" scope="prototype">
			<constructor-arg value="12"></constructor-arg>
			<constructor-arg value="instanceBeanPerson"></constructor-arg>
		</bean>
	
		<bean id="instanceFactory-person2" class="com.springsource.factorymethodstudy.Person" factory-bean="wzyInstanceBeanFactory" factory-method="createPerson" scope="singleton">
			<constructor-arg value="13"></constructor-arg>
		</bean>
	```




### 11.spring 创建Bean 构造器的匹配选择



1. 第一次创建默认resolve/autowire属性都是false。都进不来,后续如果再进来 resolved就为true

	```java 
	//如果之前找到了匹配的构造器，实例化了相应对象，那么直接从对应BD的构造你缓存中取出对应构造器，进行实例化.第一次实例化默认都是进不来的
			if (resolved) {
				//自动注入构造器，可以按照参数类型
				if (autowireNecessary) {
					return autowireConstructor(beanName, mbd, null, null);
				}
				else {
					return instantiateBean(beanName, mbd);
				}
			}
	```

	

2. 如果设置了constructor-args那么就会进入autowire自动选择构造器的阶段,此过程的构造器选择：会先把所有这个BD的所有构造器按照参数个数排序,会根据传入的参数个数判断，选择对应的构造器。如果选择成功，那么久仿佛此BD的构造器缓存中，方便后续直接调用.不用再选择。（对于多例模式来说）

	```java 
	
	
	//根据各种条件（传入的constructorArgs是否为空，不为空则进入）
			if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
					mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
				return autowireConstructor(beanName, mbd, ctors, args);
			}
	
	\\===============================================================================
	    protected BeanWrapper autowireConstructor(
				String beanName, RootBeanDefinition mbd, @Nullable Constructor<?>[] ctors, @Nullable Object[] explicitArgs) {
	
			return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
		}
	\\================================================================================
	    //如果构造器选择成功,那么将构造器加入BeanDefinition的构造器缓存之中,方便下次直接调用
				if (explicitArgs == null && argsHolderToUse != null) {
					argsHolderToUse.storeCache(mbd, constructorToUse);
				}
	
	```

	

3. 选择构造器的各种情况:

	1. 传入的有constructor-args有构造参数条件:mbd.hasConstructorArgumentValues()

		

	2. 有@AutoWired注解修饰构造器,此前会通过context标签的componentScan的parse()方法注册一些内部BFPP,BPP的BD 其中一个重要的BPP就是AutowiredAnnotationBeanPostProcessor,此类继承了SmartInstantiationAwareBeanPostProcessor和MergedBeanDefinitionPostProcessor，并且重写了determineCandidateConstructors方法

		```java  
		 //转换AutowiredAnnotationBeanPostProcessor 为BeanDefinition
				if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {
					RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);
					def.setSource(source);
					beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));
				}
		
		\\===========================================================================
		    	protected Constructor<?>[] determineConstructorsFromBeanPostProcessors(@Nullable Class<?> beanClass, String beanName)
					throws BeansException {
		
				if (beanClass != null && hasInstantiationAwareBeanPostProcessors()) {
					for (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) {
						Constructor<?>[] ctors = bp.determineCandidateConstructors(beanClass, beanName);
						if (ctors != null) {
							return ctors;
						}
					}
				}
				return null;
			}
		    
		
		```

	3. 







### 12. spring实例化的策略模式(InstantiationStrategy接口)方法的重载，通过传参不同来调用不同的策略

1.  SimpleInstantiationStrategy模式实例化普通Bean 
	1. 根据无参构造器实例化
	2. 根据有参构造器实例化
	3. 根据工厂 factory-method实例化

2.  CglibSubclassingInstantiationStrategy  CgLib模式实例化代理Bean  代理模式下也需要目标对象，因此需要目标对象的构造器
	1. 根据无参构造器实例化代理类
	2. 根据有参构造器实例化代理类



### 13 .MergedBeanDefinitionPostProcessors的重写方法修改BD的信息，选出需要注入值的所有属性，和方法

1. CommonAnnotationBeanPostProcessor是MBP的子接口，并且重写了它的实现方法，因此，在此会调用ABP的重写方法,此方法的第一个目的在于获取所有Bean(包括其所有父类，不包含静态) 的@postConstructor@preDestroy修饰的方法，并且后续设置BD当中，方便调用

	

```java 
	public CommonAnnotationBeanPostProcessor() {
		setOrder(Ordered.LOWEST_PRECEDENCE - 3);
		setInitAnnotationType(PostConstruct.class);
		setDestroyAnnotationType(PreDestroy.class);
		ignoreResourceType("javax.xml.ws.WebServiceContext");
	}

//==========================================================================

//执行MergedBeanDefinitionPostProcessors的重写方法
synchronized (mbd.postProcessingLock) {
			if (!mbd.postProcessed) {
				try {
					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
				}
				catch (Throwable ex) {
					throw new BeanCreationException(mbd.getResourceDescription(), beanName,
							"Post-processing of merged bean definition failed", ex);
				}
				mbd.postProcessed = true;
			}
		}
\\==============================================================================
protected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class<?> beanType, String beanName) {
		//判断当前Bean是否MergedBeanDefinitionPostProcessor ,如果是的话加入缓存并且，执行postProcessMergedBeanDefinition方法
		for (MergedBeanDefinitionPostProcessor processor : getBeanPostProcessorCache().mergedDefinition) {
			processor.postProcessMergedBeanDefinition(mbd, beanType, beanName);
		}
	}

\\=============================================================================
	@Override
	public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {
		super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);
		InjectionMetadata metadata = findResourceMetadata(beanName, beanType, null);
		metadata.checkConfigMembers(beanDefinition);
	}

\\===============================================================================
@Override
	public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {
		//获取此类以及所有父类的postConsturctor方法以及preDestroy方法，并且初始化为lifecycleMeta包装对象
		LifecycleMetadata metadata = findLifecycleMetadata(beanType);
    //将lifemeta相关信息注册到当前BD当中
		metadata.checkConfigMembers(beanDefinition);
	}

\\======================================================================
    	private LifecycleMetadata findLifecycleMetadata(Class<?> clazz) {
		if (this.lifecycleMetadataCache == null) {
			// Happens after deserialization, during destruction...
			return buildLifecycleMetadata(clazz);
		}
		// Quick check on the concurrent map first, with minimal locking.
		LifecycleMetadata metadata = this.lifecycleMetadataCache.get(clazz);
		if (metadata == null) {
			synchronized (this.lifecycleMetadataCache) {
				metadata = this.lifecycleMetadataCache.get(clazz);
				if (metadata == null) {
					metadata = buildLifecycleMetadata(clazz);
					this.lifecycleMetadataCache.put(clazz, metadata);
				}
				return metadata;
			}
		}
		return metadata;
	}

\\==============================================================================
	//遍历获取当前类以及他的所有父类的@postConstructor方法以及@preDestroy方法
		do {
			final List<LifecycleElement> currInitMethods = new ArrayList<>();
			final List<LifecycleElement> currDestroyMethods = new ArrayList<>();

			ReflectionUtils.doWithLocalMethods(targetClass, method -> {
				if (this.initAnnotationType != null && method.isAnnotationPresent(this.initAnnotationType)) {
					LifecycleElement element = new LifecycleElement(method);
					currInitMethods.add(element);
					if (logger.isTraceEnabled()) {
						logger.trace("Found init method on class [" + clazz.getName() + "]: " + method);
					}
				}
				if (this.destroyAnnotationType != null && method.isAnnotationPresent(this.destroyAnnotationType)) {
					currDestroyMethods.add(new LifecycleElement(method));
					if (logger.isTraceEnabled()) {
						logger.trace("Found destroy method on class [" + clazz.getName() + "]: " + method);
					}
				}
			});

			initMethods.addAll(0, currInitMethods);
			destroyMethods.addAll(currDestroyMethods);
			targetClass = targetClass.getSuperclass();
		}
		while (targetClass != null && targetClass != Object.class);
```



<font color='red'>(@PostConstuctor后续会在初始化完成后applyBeanPostProcessorsBeforeInitialization的调用，会在后续)</font>

```java  
if (mbd == null || !mbd.isSynthetic()) {
			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
		}

//========================================================================
@Override
	public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
			throws BeansException {

		Object result = existingBean;
		for (BeanPostProcessor processor : getBeanPostProcessors()) {
			Object current = processor.postProcessBeforeInitialization(result, beanName);
			if (current == null) {
				return result;
			}
			result = current;
		}
		return result;
	}
//========================================================================	
@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());
		try {
			metadata.invokeInitMethods(bean, beanName);
		}
		catch (InvocationTargetException ex) {
			throw new BeanCreationException(beanName, "Invocation of init method failed", ex.getTargetException());
		}
		catch (Throwable ex) {
			throw new BeanCreationException(beanName, "Failed to invoke init method", ex);
		}
		return bean;
	}
```



<font color='red'>@PreDestroy后续会在初始化完成后的调用)在容器的close()方法中destroySingleton()的destroy()调用</font><font color='red'>DestructionAwareBeanPostProcessor的postProcessBeforeDestruction方法从而调用destory方法</font>

```java  
	@Override
	public void destroy() {
		if (!CollectionUtils.isEmpty(this.beanPostProcessors)) {
			for (DestructionAwareBeanPostProcessor processor : this.beanPostProcessors) {
				processor.postProcessBeforeDestruction(this.bean, this.beanName);
			}
		}
```



2. CommonAnnotationBeanPostProcessor 的重写方法不仅会完成postConstuctor,predestory注解的扫描，还会完成(包括其所有父类，不包含静态) @Resource注解的扫描，解析工作,完成之后将注解相关信息注册到BD当中

	```java 
		public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {
			//调用父类的postProcessMergedBeanDefinition方法,完成@PostConstructor,@PreDestory的解析工作
			super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);
			//寻找@Resource注解
			InjectionMetadata metadata = findResourceMetadata(beanName, beanType, null);
	        	//将@Resource相关信息注册到对应BD当中
			metadata.checkConfigMembers(beanDefinition);
		}
	\\=============================================================================
	private InjectionMetadata findResourceMetadata(String beanName, final Class<?> clazz, @Nullable PropertyValues pvs) {
			// Fall back to class name as cache key, for backwards compatibility with custom callers.
			String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());
			// Quick check on the concurrent map first, with minimal locking.
			InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);
			if (InjectionMetadata.needsRefresh(metadata, clazz)) {
				synchronized (this.injectionMetadataCache) {
					metadata = this.injectionMetadataCache.get(cacheKey);
					if (InjectionMetadata.needsRefresh(metadata, clazz)) {
						if (metadata != null) {
							metadata.clear(pvs);
						}
						metadata = buildResourceMetadata(clazz);
						this.injectionMetadataCache.put(cacheKey, metadata);
					}
				}
			}
			return metadata;
		}
	
	
	\\============================================================
	```



3. AutowiredAnnotationBeanPostProcessor 也是MBP的子接口，也重写了方法，因此也会再次调用。它的主要工作室完成类(包括其所有父类，不包含静态) 属性，方法的@Autowired/@Value的解析，并且也是将相关信息注册到BD当中去.

	 ```java 
	 
	```

		@Override
		public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) {
			//指定类中寻找所有的@AutoWired注解
			InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null);
			//将@AutoWired注解修饰的元数据信息注册到BD当中
			metadata.checkConfigMembers(beanDefinition);
		}
	\\================================================================================
	    
	    	private InjectionMetadata findAutowiringMetadata(String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {
	    	// Fall back to class name as cache key, for backwards compatibility with custom callers.
	    	String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());
	    	// Quick check on the concurrent map first, with minimal locking.
	    	InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);
	    	if (InjectionMetadata.needsRefresh(metadata, clazz)) {
	    		synchronized (this.injectionMetadataCache) {
	    			metadata = this.injectionMetadataCache.get(cacheKey);
	    			if (InjectionMetadata.needsRefresh(metadata, clazz)) {
	    				if (metadata != null) {
	    					metadata.clear(pvs);
	    				}
	    				//获取类@AutoWired的元数据信息
	    				metadata = buildAutowiringMetadata(clazz);
	    				this.injectionMetadataCache.put(cacheKey, metadata);
	    			}
	    		}
	    	}
	    	return metadata;
	    }
	\\============================================================
	    
	
	```
	
	```


​	



### 14.Spring 三级缓存解决Bean的循环依赖问题

1. 为什么会产生循环依赖问题？

	一个Bean的属性有另一个Bean,另一个Bean的属性也有此Bean.创建对象的时候都需要各自。导致死循环，无法完成循环依赖.

2. 如何解决循环依赖问题？

	1. 将实例化，初始化分开,在Bean创建的过程中先不考虑属性的赋值，先实例化，并且将自己提前暴露给其他对象引用.
	2. 对象的引用的地址，全局不变。此时需要将半成品，成品对象区分，因为他们的用处不同，最终提供给用户使用的是成品对象，而在初始化阶段需要先用到半成品对象，之后再将半成品对象完成属性的赋值，所以可以设计两个map,两个map的key存放BeanName  一个map的value存放半成品对象，一个map的value存放成品对象.根据beanName 来获取，保证获取的对象引用地址相同。
	3. 至此，普通对象的循环依赖问题已被两个map解决。但是spring当中会有代理对象。当一个对象被代理时，我们需要知道一个对象到底是不是代理对象，以及什么时候创建代理对象。
	4. 代理对象具有被代理对象的所有功能，可以替代原对象。所以我们要先创建出完整的原对象，才能创建出代理对象。有了代理对象之后，就可以不需要再使用原对象了
	5. 我们可以在生成半成品对象之后，传入一个匿名内部类。里面重写方法中判断此对象是不是需要代理，以及具体的代理过程。在需要代理对象的时候，直接调用匿名内部类的重写方法
	6. 因此我们还需要一个map用来存放为了生成代理对象的匿名内部类。利用他的回调机制，完成对象的代理
	7. 有的对象自身需要被代理。属性对象不需要被代理。而有的对象自身需要被代理，且属性对象也需要被代理。对于第一种情况，我们可以利用BeanPostProcessor的after方法，在此方法中，回调匿名内部类的重写方法.对于第二种情况，我们需要在属性值被赋值时，完成对象的代理.







### 15.Spring Bean创建属性值的注入 xml标签形式注入（必须要有属性的set方法）

#### 15.1 autowiredbyName

1. 根据属性的名称去容器中获取对应对象,发现有符合的BeanName的Bean或者BD就进行赋值。

	```java 
	//开始Bean的实例化,获取要填充的属性值
	populateBean(beanName, mbd, instanceWrapper);
	//================================================================================
	//获取BD当中的property与value
			PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);
	        //获取bean的注入方式，可以是byname,bytype,byconstuctor,
			int resolvedAutowireMode = mbd.getResolvedAutowireMode();
			if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
				//包装一个获取的PropertyValues对象
				MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
				// Add property values based on autowire by name if applicable.
				//如果指定是byName的话采用byName的方式获取该属性值
				if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
					//具体注入步骤
					autowireByName(beanName, mbd, bw, newPvs);
				}
				// Add property values based on autowire by type if applicable.
				//如果指定是byType的话采用byType的方式获取该属性值
				if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
					autowireByType(beanName, mbd, bw, newPvs);
				}
				pvs = newPvs;
			}
	//================================================================================
	//获取非基本类型，非基本类型的包装和数组
			String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);
			for (String propertyName : propertyNames) {
				if (containsBean(propertyName)) {
					//判断Bean是否存在或BD是否存在(如果存在直接获取，不存在则开始doCreatBean)
					Object bean = getBean(propertyName);
					pvs.add(propertyName, bean);
					//如果Bean之间有依赖关系的话，则缓存中记录这种依赖关系，方便下次调用
					registerDependentBean(propertyName, beanName);
					if (logger.isTraceEnabled()) {
						logger.trace("Added autowiring by name from bean name '" + beanName +
								"' via property '" + propertyName + "' to bean named '" + propertyName + "'");
					}
				}
				else {
					if (logger.isTraceEnabled()) {
						logger.trace("Not autowiring property '" + propertyName + "' of bean '" + beanName +
								"' by name: no matching bean found");
					}
				}
	
	
	
	```

	

#### 15.2 autowiredbyType

1. 根据属性的类型去获取对应对象，发现有对应类型的Bean和BD就进行注入

2. 注意如果是集合类型的话，他会把容器中所有符合类型的集合注入，候选者集合是一个string,Object的map

	Object里面是候选Bean。

	string 存储的属性名称，之后会将候选者Object赋值给对应的属性。属性值的类型和候选者集合Object的类型匹配的话，那么就会赋值成功

	```java 
	 //获取自定义类型转换器，如果为null的话自动设置Bean的包装类型BW
			TypeConverter converter = getCustomTypeConverter();
			if (converter == null) {
				converter = bw;
			}
	
			Set<String> autowiredBeanNames = new LinkedHashSet<>(4);
			//获取非基本类型，非基本类型的包装和他们的数组
			String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);
			for (String propertyName : propertyNames) {
				try {
					PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);
					// Don't try autowiring by type for type Object: never makes sense,
					// even if it technically is a unsatisfied, non-simple property.
					//排除Object的类型属性
					if (Object.class != pd.getPropertyType()) {
						//获取属性的set方法
						MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);
						// Do not allow eager init for type matching in case of a prioritized post-processor.
						boolean eager = !(bw.getWrappedInstance() instanceof PriorityOrdered);
						//创建依赖描述符
						DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);
						//寻找对应的属性值
						Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);
						if (autowiredArgument != null) {
							pvs.add(propertyName, autowiredArgument);
						}
						//注册依赖关系
						for (String autowiredBeanName : autowiredBeanNames) {
							registerDependentBean(autowiredBeanName, beanName);
							if (logger.isTraceEnabled()) {
								logger.trace("Autowiring by type from bean name '" + beanName + "' via property '" +
										propertyName + "' to bean named '" + autowiredBeanName + "'");
							}
						}
						autowiredBeanNames.clear();
					}
	               
	\\================================================================================
	    //默认普通类型的属性进入此方法
				if (result == null) {
					result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
				}
	\\=======================================================================
	    	//如果集合类型是一个用户自定义类型返回
				Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);
				if (multipleBeans != null) {
					return multipleBeans;
				}
	
				//按类型寻找容器对应的Bean
				Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
				if (matchingBeans.isEmpty()) {
					if (isRequired(descriptor)) {
						raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
					}
					return null;
				}
	                
	                
	\\================================================================================      	//2. 类型查找：本质上递归调用beanFactory#beanNamesForType。先匹配工厂，再匹配bd。找到所有类型匹配的Bean的名称
			String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
					this, requiredType, true, descriptor.isEager());
	                
	                for (String candidate : candidateNames) {
				if (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, descriptor)) {
					//把获取到符合Bean类型的BD的名字传入，并且返回候选者对象
					addCandidateEntry(result, candidate, descriptor, requiredType);
				}
			}
	                \\=================================================================
	                    //获取到匹配类型的所有后选择Bean，加入候选者集合
				else {
				//获取到匹配类型的所有后选择Bean，加入候选者集合
				candidates.put(candidateName, getType(candidateName));
			}
	    
	```

	

###16 @Autowired注解修饰属性的注入(@Resource类似，但是另一个CommonBPP注入处理的)，@Autowired可以修饰属性，注入属性，也可以修饰方法，将获取方法参数，在调用方法。

1. 在配置文件autowired 赋值以后，会再一次遍历InnstationBeanProcessor接口的实现类，并且会调用他们的实现方法pocessProperties()方法。而AnnotationBPP恰好是该接口的实现类，并且会他的实现方法。完成了对象被@AutoWired注解修饰的属性的赋值

	```java 
	//如果含有InstantiationAwareBeanPostProcessor的话，则嗲用该重写方法,此处如果开启注解配置的话，会通过
	//AutoWiredAnnotationBPP的重写方法，完成@Autowird属性的赋值，因为此前的一个BFPP已经获取了被他修饰的属性
	for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {
	    PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
	    if (pvsToUse == null) {
	        if (filteredPds == null) {
	            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
	        }
	        pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
	        if (pvsToUse == null) {
	            return;
	        }
	    }
	    pvs = pvsToUse;
	}
	}
	
	\\==========================================================================
	    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {
	    InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);
	    try {
	        //为@autowired注解修饰的属性赋值
	        metadata.inject(bean, beanName, pvs);
	    }
	    catch (BeanCreationException ex) {
	        throw ex;
	    }
	    catch (Throwable ex) {
	        throw new BeanCreationException(beanName, "Injection of autowired dependencies failed", ex);
	    }
	    return pvs;
	}
	\\==============================================================================
	    Object value;
	try {
	    //寻找注解修饰属性的值,注意此处就是配置文件按照配置文件注入的：先ByType注入，如果不存在报错，如果发现多个再根据beanName去匹配
	    value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
	}
	catch (BeansException ex) {
	    throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex);
	}
	
	```

	







### 17.Spring标签形式的属性赋值

1. 获取AutoWiredByName/AutowiredByType 之前获取的Bean或者 BD

```java 
//获取对象属性的值查找
Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);
```

2. 如果是RunTimeReference 则从BeanFactory getBean(name)

	```java 
	if (value instanceof RuntimeBeanReference) {
				RuntimeBeanReference ref = (RuntimeBeanReference) value;
				return resolveReference(argName, ref);
			}
	\\============================================================================
	else {
	resolvedName = String.valueOf(doEvaluate(ref.getBeanName()));
	bean = this.beanFactory.getBean(resolvedName);
	}
	this.beanFactory.registerDependentBean(resolvedName, this.beanName);
	```

	

3. 此时对value 有一个非常多的判断包括LIST /MAP 等等。。。。。。不同值的类型 有不同的处理方式





### 18.总结Spring 创建Bean对象的阶段（最重要）

#### 1. doCreatBean()  

1. 从一级缓存中去获取，如果存在直接返回。

2. 如果不存在，开始正式的创建流程。

	```java 
	//开始Bean的实例化
	sharedInstance = getSingleton(beanName, () -> {
	    try {
	        return createBean(beanName, mbd, args);
	    }
	    catch (BeansException ex) {
	        // Explicitly remove instance from singleton cache: It might have been put there
	        // eagerly by the creation process, to allow for circular reference resolution.
	        // Also remove any beans that received a temporary reference to the bean.
	        destroySingleton(beanName);
	        throw ex;
	    }
	});
	```

	

#### 2.Bean的创建

#####1.Bean的实例化

```java 
	Object beanInstance = doCreateBean(beanName, mbdToUse, args);
//====================================================================================
//（1）.创建bean包装类BealWrapper，这段代码执行结束，说明bean已经构建完成，在堆上创建了实例
			instanceWrapper = createBeanInstance(beanName, mbd, args);
//====================================================================================

```



##### 2.Bean的初始化

###### 1.首先发现@AutoWired注解，@Resource,@PostConstructor@PostBean修饰的属性或者方法,并且暂存到缓存中去.

```java 
//执行MergedBeanDefinitionPostProcessors的重写方法,非常重要,完成各类注解的解析工作  @AutoWired,@Resource,@PostConstructor....
		synchronized (mbd.postProcessingLock) {
			if (!mbd.postProcessed) {
				try {
					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
				}
				catch (Throwable ex) {
					throw new BeanCreationException(mbd.getResourceDescription(), beanName,
							"Post-processing of merged bean definition failed", ex);
				}
				mbd.postProcessed = true;
			}
		}
```





###### 2.提前暴露对象，解决循环依赖问题

```java 
//这里非常重要，这里就是传入一个匿名内部类。内部类中含有一个判断对象是否需要动态代理的回调方法。
		boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
				isSingletonCurrentlyInCreation(beanName));
		if (earlySingletonExposure) {
			if (logger.isTraceEnabled()) {
				logger.trace("Eagerly caching bean '" + beanName +
						"' to allow for resolving potential circular references");
			}
			addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
		}
```



######3.提前暴露对象解决循环依赖问题

```java 
//这里非常重要，这里就是传入一个匿名内部类。内部类中含有一个判断对象是否需要动态代理的回调方法。
		boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
				isSingletonCurrentlyInCreation(beanName));
		if (earlySingletonExposure) {
			if (logger.isTraceEnabled()) {
				logger.trace("Eagerly caching bean '" + beanName +
						"' to allow for resolving potential circular references");
			}
			addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
		}
```





###### 4.开始Bean的属性值的赋值

```java 
//开始Bean的实例化,获取要填充的属性值
			populateBean(beanName, mbd, instanceWrapper);
```



##### 4.1发现所有符合条件的属性值，先以xml标签的值为主，如果标签是自动装配类型的话，则按类型获取属性值，或者按名称获取属性值.

```java 
PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);//获取BD当中的property与value
PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);
//获取bean的注入方式，可以是byname,bytype,byconstuctor,
int resolvedAutowireMode = mbd.getResolvedAutowireMode();
if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
    //包装一个获取的PropertyValues对象
    MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
    // Add property values based on autowire by name if applicable.
    //如果指定是byName的话采用byName的方式获取该属性值
    if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
        //具体注入步骤
        autowireByName(beanName, mbd, bw, newPvs);
    }
    // Add property values based on autowire by type if applicable.
    //如果指定是byType的话采用byType的方式获取该属性值
    if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
        autowireByType(beanName, mbd, bw, newPvs);
    }
    pvs = newPvs;
}
```



##### 4.2发现被@AutoWired @Qualified修饰的属性的值,此自动装配注解的属性之前已经完成了发现，现在主要是通过AutoWiredBeanPostProcessor进行符合条件的属性值，以及属性值的注入。

```java 
//如果开启注解功能，自动初始化一个空的PropertyValue
if (hasInstAwareBpps) {
    if (pvs == null) {
        pvs = mbd.getPropertyValues();
    }
    //如果含有InstantiationAwareBeanPostProcessor的话，则嗲用该重写方法,此处如果开启注解配置的话，会通过
    //AutoWiredAnnotationBPP的重写方法，完成@Autowird属性的赋值，因为此前的一个BFPP已经获取了被他修饰的属性
    for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {
        PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
        if (pvsToUse == null) {
            if (filteredPds == null) {
                filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
            }
            pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
            if (pvsToUse == null) {
                return;
            }
        }
        pvs = pvsToUse;
    }
}
```



##### 4.3填充属性,此过程按属性的类型，把之前标签配置的值，进行查找转换，并且利用set方法的反射最终赋值给实例化的对象，深拷贝一个PropertyValue 。防止后续对值的转换影响到原有值。

```java 
if (pvs != null) {
    applyPropertyValues(beanName, mbd, bw, pvs);
}
\\====================================================================================
    ph.setValue(valueToApply);
\\====================================================================================
    ReflectionUtils.makeAccessible(writeMethod);
writeMethod.invoke(getWrappedInstance(), value);

```



##### 4.4 填充属性值之后  

1. 调用实现了BeanNameWare,BeanClassLoaderAware,BeanFactoryAware接口的方法，将beanName,classLoader,beanFactory的名称传递给自身.

```java 
//调用初始化方法
exposedObject = initializeBean(beanName, exposedObject, mbd);
//调用aware接口的实现方法,获取BeanName,BeanFactory,BeanClassLoader
		if (System.getSecurityManager() != null) {
			AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
				invokeAwareMethods(beanName, bean);
				return null;
			}, getAccessControlContext());
		}
		else {
			invokeAwareMethods(beanName, bean);
		}



```

2. init-Method之前,调用前置处理BPP(比如CommonBPP 的@PostConstructor修饰的方法)

	```java 
	//初始化之前，调用所哟前置处理方法
	Object wrappedBean = bean;
			if (mbd == null || !mbd.isSynthetic()) {
				wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
			}
	
	```

	

3. init-Method方法 如果之前已有@POSTcoStructor修饰的方法 那么此过程不会调用。

	在此过程之前还有个一个对实现InitalizingBean接口Bean的afterPropertiesSet的调用。最后一个改变Bean的属性值

	```java 
	try {
	    invokeInitMethods(beanName, wrappedBean, mbd);
	}
	catch (Throwable ex) {
	    throw new BeanCreationException(
	        (mbd != null ? mbd.getResourceDescription() : null),
	        beanName, "Invocation of init method failed", ex);
	}
	
	
	if (isInitializingBean && (mbd == null || !mbd.isExternallyManagedInitMethod("afterPropertiesSet"))) {
				if (logger.isTraceEnabled()) {
					logger.trace("Invoking afterPropertiesSet() on bean with name '" + beanName + "'");
				}
				if (System.getSecurityManager() != null) {
					try {
						AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> {
							((InitializingBean) bean).afterPropertiesSet();
							return null;
						}, getAccessControlContext());
					}
					catch (PrivilegedActionException pae) {
						throw pae.getException();
					}
				}
				else {
					((InitializingBean) bean).afterPropertiesSet();
				}
			}
	
	
	if (mbd != null && bean.getClass() != NullBean.class) {
				String initMethodName = mbd.getInitMethodName();
				if (StringUtils.hasLength(initMethodName) &&
						!(isInitializingBean && "afterPropertiesSet".equals(initMethodName)) &&
						!mbd.isExternallyManagedInitMethod(initMethodName)) {
					invokeCustomInitMethod(beanName, bean, mbd);
				}
			}
	```

4. 调用后置处理BPP方法

	```java 
	//调用BPP后置处理方法
	if (mbd == null || !mbd.isSynthetic()) {
	    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
	}
	```









## 19.Spring循环依赖问题

### 1.什么是循环依赖问题？

1.A的创建需要属性B有值 B的创建需要A属性有值 导致无限循环，创建Bean失败  



### 2.如何解决循环依赖问题？

1.将创建对象的阶段分为实例化与初始化。实例化完成之后。对外暴露对象，给其他创建Bean的过程使用。



### 3.为什么需要二级缓存？

1.如果只有一个Map  那么将无法正确区分半成品对象与成品对象。如果在多线程环境下，不同线程只通过一个Map获取对象的话，那么有可能在获取成品对象的时候，取到了半成品对象。导致出错。



### 4.为什么需要三级缓存？

1.普通对象的循环依赖问题，用两个Map解决足矣。

2.涉及到代理对象的循环依赖问题，用两级工厂就无法解决了。

如果一个对象需要代理，那么可以在Bean创建完成之后再生成代理对象。

但是如果这个对象需要被别的对象引用，那么被引用的时候只在初始化完成之前还是之后，就无从得知。

有两个解决方案：

1. 代理对象不管有没有被引用，实例化完成之后立即生成代理对象。方便被引用。
2. 在对象被引用的时候，判断需不需要代理，如果需要，直接再进行代理.（利用匿名内部类的回调机制）

spring采取的是第二种

如果采用第一种，用二级缓存也是可以的，但是违背spring的设计原则。springBean的创建过程，就是要将生成代理放在初始化完成之后。大多数代理对象不存在被引用问题，所以依然代理在初始化完成之后。

只有某些特殊情况，作为代理同时又被引用了。这样spring不得不在被引用的时候完成对象的代理。防止被引用对象与代理对象不同。





#### 5.代理对象创建入口

1.自身初始化过程中完成代理对象的生成--------------》BPP的postAfterInitalization重写方法在Bean实例化，初始化完成之后。

2.作为别的对象的属性，完成代理对象的生成------------------》传入三级缓存的匿名内部类getEarlyReference()

注意：如果进行过 getEarlyReference()了，那么后续BPP就会获取到缓存中的代理对象，不会进行二次代理了.



##20.SpringAOP

### 1.AOP 准备工作：AOP有关BeanDefinition的注入

####1.解析<aop:config>标签注入AspectJAwareAdvisorAutoProxyCreator BD

1. 当解析到<aop> namespace的标签时，会获取namesapceUri 并且会实例化 AopNamespaceHandler这个内类，并且执行此类的init方法，注册一些标签的解析器

```java 
@Override
public void init() {
    // In 2.0 XSD as well as in 2.5+ XSDs
    registerBeanDefinitionParser("config", new ConfigBeanDefinitionParser());
    registerBeanDefinitionParser("aspectj-autoproxy", new AspectJAutoProxyBeanDefinitionParser());
    registerBeanDefinitionDecorator("scoped-proxy", new ScopedProxyBeanDefinitionDecorator());

    // Only in 2.0 XSD: moved to context namespace in 2.5+
    registerBeanDefinitionParser("spring-configured", new SpringConfiguredBeanDefinitionParser());
}
```





2. 将AspectJAwareAdvisorAutoProxyCreator注入到工厂的BD当中，并且key的名称是innerinternalAutoProxyCreator

	注意AspectJAwareAdvisorAutoProxyCreator是之前AbstractAutoProxyCreator的子类

	```java 
	//将AspectJAwareAdvisorAutoProxyCreator 这个类的BD注入到工厂当中 BD的名字为internalAutoProxyCreator
	configureAutoProxyCreator(parserContext, element);
	//===============================================================
	private void configureAutoProxyCreator(ParserContext parserContext, Element element) {
	    AopNamespaceUtils.registerAspectJAutoProxyCreatorIfNecessary(parserContext, element);
	}
	\\===================================================================
	    //首次向BD中注入AspectJAwareAdvisorAutoProxyCreator
	    BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAutoProxyCreatorIfNecessary(
	    parserContext.getRegistry(), parserContext.extractSource(sourceElement));
	useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);
	//再次向工厂注入internalAutoProxyCreator 这个BD
	registerComponentIfNecessary(beanDefinition, parserContext);
	\\===============================================================================
	```



#### 2.解析<aop:config>的子类标签 比如 <aop:aspect> <aop:pointCut>  <aop:advisor  >

1.<aop:aspect>解析

1. 寻找before,after,around,afterReturn,afterThrowing 的节点 

	```java 
	//分类创建不同的advistorBD 
	AbstractBeanDefinition advisorDefinition = parseAdvice(
	    aspectName, i, aspectElement, (Element) node, parserContext, beanDefinitions, beanReferences);
	beanDefinitions.add(advisorDefinition);
	\\===========================================================================
	    //创建Method对应的BD
	    RootBeanDefinition methodDefinition = new RootBeanDefinition(MethodLocatingFactoryBean.class);
	//设置Method-BD的targetBeanName
	methodDefinition.getPropertyValues().add("targetBeanName", aspectName);
	//设置Method-BD 的methodName
	methodDefinition.getPropertyValues().add("methodName", adviceElement.getAttribute("method"));
	methodDefinition.setSynthetic(true);
	
	// create instance factory definition
	//创建BeanFactoryAware的BD
	RootBeanDefinition aspectFactoryDef =
	    new RootBeanDefinition(SimpleBeanFactoryAwareAspectInstanceFactory.class);
	aspectFactoryDef.getPropertyValues().add("aspectBeanName", aspectName);
	aspectFactoryDef.setSynthetic(true);
	
	// register the pointcut
	//创建advisor的BD,将之前创建好的Method-BD 以及BeanFactoryAware的BD传入其中，设置到advior的构造器参数当中去
	AbstractBeanDefinition adviceDef = createAdviceDefinition(
	    adviceElement, parserContext, aspectName, order, methodDefinition, aspectFactoryDef,
	    beanDefinitions, beanReferences);
	
	// configure the advisor
	//创建AspectJPointcutAdvisor相关的BD，他的构造器参数是之前的advisorBD
	RootBeanDefinition advisorDefinition = new RootBeanDefinition(AspectJPointcutAdvisor.class);
	advisorDefinition.setSource(parserContext.extractSource(adviceElement));
	advisorDefinition.getConstructorArgumentValues().addGenericArgumentValue(adviceDef);
	if (aspectElement.hasAttribute(ORDER_PROPERTY)) {
	    advisorDefinition.getPropertyValues().add(
	        ORDER_PROPERTY, aspectElement.getAttribute(ORDER_PROPERTY));
	}
	
	// register the final advisor
	//向工厂中注入BD  BD可以分，指定BD的名称为AspectJPointcutAdvisor#1,2......10
	parserContext.getReaderContext().registerWithGeneratedName(advisorDefinition);
	\\==============================================================================
	    //创建对应advisor的BD 他的ClassType可能是before,after,around对应的adviorBD
	    RootBeanDefinition adviceDefinition = new RootBeanDefinition(getAdviceClass(adviceElement, parserContext));
	adviceDefinition.setSource(parserContext.extractSource(adviceElement));
	
	adviceDefinition.getPropertyValues().add(ASPECT_NAME_PROPERTY, aspectName);
	adviceDefinition.getPropertyValues().add(DECLARATION_ORDER_PROPERTY, order);
	
	if (adviceElement.hasAttribute(RETURNING)) {
	    adviceDefinition.getPropertyValues().add(
	        RETURNING_PROPERTY, adviceElement.getAttribute(RETURNING));
	}
	if (adviceElement.hasAttribute(THROWING)) {
	    adviceDefinition.getPropertyValues().add(
	        THROWING_PROPERTY, adviceElement.getAttribute(THROWING));
	}
	if (adviceElement.hasAttribute(ARG_NAMES)) {
	    adviceDefinition.getPropertyValues().add(
	        ARG_NAMES_PROPERTY, adviceElement.getAttribute(ARG_NAMES));
	}
	//获取advisor对应的constructor
	ConstructorArgumentValues cav = adviceDefinition.getConstructorArgumentValues();
	//给构造器的参数设置值，第一个是method 的BD
	cav.addIndexedArgumentValue(METHOD_INDEX, methodDef);
	//创建advisor的pointCUt或者pointRef属性,并且设置构造器的第二个参数是pointCUT
	Object pointcut = parsePointcutProperty(adviceElement, parserContext);
	if (pointcut instanceof BeanDefinition) {
	    cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcut);
	    beanDefinitions.add((BeanDefinition) pointcut);
	}
	else if (pointcut instanceof String) {
	    RuntimeBeanReference pointcutRef = new RuntimeBeanReference((String) pointcut);
	    cav.addIndexedArgumentValue(POINTCUT_INDEX, pointcutRef);
	    beanReferences.add(pointcutRef);
	}
	//设置构造器的第三个参数是BeanFactory
	cav.addIndexedArgumentValue(ASPECT_INSTANCE_FACTORY_INDEX, aspectFactoryDef);
	```

	

2. 转换<aspect>下的<pointCut>子标签,它的BD为AspectJExpressionPointcut

	```java 
	List<Element> pointcuts = DomUtils.getChildElementsByTagName(aspectElement, POINTCUT);
	for (Element pointcutElement : pointcuts) {
	    //转换Aspect下的 pointCut子标签
	    parsePointcut(pointcutElement, parserContext);
	}
	\\================================================================================
	    //创建AspectJExpressionPointcut PointCut标签的BD
	    pointcutDefinition = createPointcutDefinition(expression);
	pointcutDefinition.setSource(parserContext.extractSource(pointcutElement));
	
	String pointcutBeanName = id;
	if (StringUtils.hasText(pointcutBeanName)) {
	    //向工厂注入AspectJExpressionPointcut BD
	    parserContext.getRegistry().registerBeanDefinition(pointcutBeanName, pointcutDefinition);
	}
	else {
	    pointcutBeanName = parserContext.getReaderContext().registerWithGeneratedName(pointcutDefinition);
	}
	\\=========================================================================
	    protected AbstractBeanDefinition createPointcutDefinition(String expression) {
			RootBeanDefinition beanDefinition = new RootBeanDefinition(AspectJExpressionPointcut.class);
			beanDefinition.setScope(BeanDefinition.SCOPE_PROTOTYPE);
			beanDefinition.setSynthetic(true);
			beanDefinition.getPropertyValues().add(EXPRESSION, expression);
			return beanDefinition;
		}
	```

	

### 21.SpringAOP 核心对象的创建

### 1.BPP阶段

1.registerBeanPostProcessor 会把 innerinternalAutoProxyCreator 的AwareAdvisorAutoProxyCreator的BD实例化成Bean,放入BeanFactory中，方便后续调用，因为此类实现了BPP的接口



###2.创建AOP核心BEAN，advisor阶段

1. 在被放入BeanFactory之后  因为AwareAdvisorAutoProxyCreator还是AbstractAutoProxyCreator的子类，而AbstractAutoProxyCreator实现了InstantiationAwareBeanPostProcessor接口，重写了postProcessBeforeInstantiation方法，因此在后续Bean的创建过程，会过滤AOP的核心类并且加入特定的缓存集合当中去

```java 
public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) {
    Object cacheKey = getCacheKey(beanClass, beanName);
    //一般this.targetSourcedBeans 这里都会返回true
    if (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) {
        if (this.advisedBeans.containsKey(cacheKey)) {
            return null;
        }
        //isInfrastructoureClass判断是否是Advisor,PointCut,Advice类的Bean, shouldSkip(这里会调用子类的AspectJAwareAdvisorAutoProxyCreator的重写方法
        // 判断是被引用的切面aspect，如果满足就加入缓存
        if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) {
            this.advisedBeans.put(cacheKey, Boolean.FALSE);
            return null;
        }
    }
    //========================================================================
    protected boolean shouldSkip(Class<?> beanClass, String beanName) {
        // TODO: Consider optimization by caching the list of the aspect names
        List<Advisor> candidateAdvisors = findCandidateAdvisors();
        for (Advisor advisor : candidateAdvisors) {
            if (advisor instanceof AspectJPointcutAdvisor &&
                ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) {
                return true;
            }
        }
        return super.shouldSkip(beanClass, beanName);
    }


    //===============================================================================
    protected boolean isInfrastructureClass(Class<?> beanClass) {
        boolean retVal = Advice.class.isAssignableFrom(beanClass) ||
            Pointcut.class.isAssignableFrom(beanClass) ||
                Advisor.class.isAssignableFrom(beanClass) ||
                    AopInfrastructureBean.class.isAssignableFrom(beanClass);
        if (retVal && logger.isTraceEnabled()) {
            logger.trace("Did not attempt to auto-proxy infrastructure class [" + beanClass.getName() + "]");
        }
        return retVal;
    }             
```



2. 在创建Bean的过程中在postProcessBeforeInstantiation里面，如果是非AOP相关对象，调用isInfrastructureClass方法，会返回false,因此会进入后面的shouldSkip方法，在shouldSkip方法里面会发现容器里面AOP相关的核心BD，并且开始依次实例化这些相关的Bean.这样就提前把所有AOP相关对象实例化出来了。如果是AOP相关对象，那么isisInfrastructureClass会返回true.会在之后实例化此对象。这样就保证了AOP相关对象始终被最先实例化.

	```java 
	protected boolean shouldSkip(Class<?> beanClass, String beanName) {
	    // TODO: Consider optimization by caching the list of the aspect names
	    //实例化了一些AOP相关的核心对象
	    List<Advisor> candidateAdvisors = findCandidateAdvisors();
	    for (Advisor advisor : candidateAdvisors) {
	        if (advisor instanceof AspectJPointcutAdvisor &&
	            ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) {
	            return true;
	        }
	    }
	    return super.shouldSkip(beanClass, beanName);
	}
	\\============================================================================
	    protected List<Advisor> findCandidateAdvisors() {
	    Assert.state(this.advisorRetrievalHelper != null, "No BeanFactoryAdvisorRetrievalHelper available");
	    return this.advisorRetrievalHelper.findAdvisorBeans();
	}
	\\===========================================================================
	    // Determine list of advisor bean names, if not cached already.
	    //获取之前缓存的AOP的BeanName
	    String[] advisorNames = this.cachedAdvisorBeanNames;
	if (advisorNames == null) {
	    // Do not initialize FactoryBeans here: We need to leave all regular beans
	    // uninitialized to let the auto-proxy creator apply to them!
	    //从BeanFactory当中获取所有Advisor接口实现类的BeanName
	    advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
	        this.beanFactory, Advisor.class, true, false);
	    this.cachedAdvisorBeanNames = advisorNames;
	}
	if (advisorNames.length == 0) {
	    return new ArrayList<>();
	}
	
	List<Advisor> advisors = new ArrayList<>();
	//遍历advior实现类的BeanNAME 并且进行实例化
	for (String name : advisorNames) {
	    if (isEligibleBean(name)) {
	        if (this.beanFactory.isCurrentlyInCreation(name)) {
	            if (logger.isTraceEnabled()) {
	                logger.trace("Skipping currently created advisor '" + name + "'");
	            }
	        }
	        else {
	            try {
	                //正式开始实例化Advisor实现类Bean 并且完成后加入缓存
	                advisors.add(this.beanFactory.getBean(name, Advisor.class));
	            }
	            catch (BeanCreationException ex) {
	                Throwable rootCause = ex.getMostSpecificCause();
	                if (rootCause instanceof BeanCurrentlyInCreationException) {
	                    BeanCreationException bce = (BeanCreationException) rootCause;
	                    String bceBeanName = bce.getBeanName();
	                    if (bceBeanName != null && this.beanFactory.isCurrentlyInCreation(bceBeanName)) {
	                        if (logger.isTraceEnabled()) {
	                            logger.trace("Skipping advisor '" + name +
	                                         "' with dependency on currently created bean: " + ex.getMessage());
	                        }
	                        // Ignore: indicates a reference back to the bean we're trying to advise.
	                        // We want to find advisors other than the currently created bean itself.
	                        continue;
	                    }
	                }
	                throw ex;
	            }
	        }
	    }
	}
	return advisors;
	```

	

3. 因为AspectJPointcutAdvisor此类只有一个有参构造器，所以在实例化此类对象时，必定会根据它的唯一有参构造器创建。在AOP BD的准备工作中,已经将构造器参数的BD全部设置好了。所以在此处只需要一步步根据resloveInnerBean去创建相应的对象即可。在实例化AspectJPointcutAdvisor对象即可。

 AspectJPointcutAdvisor---------------------->

AspectJAfterThrowingAdvice(也可能before,after,afterReturn,afterThrowing)---------------------->

1,MethodLocateFactoryBean 2,InstationBeanFactoryAware 3,AspectJExpressionPointcut

其中MethodLocateFactoryBean 的实例化 根据它的BD的 targetBeanName,methodName设置完成，但是method的设置在他实现的BeanFactoryAware中实现完成

```java 
	public void setBeanFactory(BeanFactory beanFactory) {
		if (!StringUtils.hasText(this.targetBeanName)) {
			throw new IllegalArgumentException("Property 'targetBeanName' is required");
		}
		if (!StringUtils.hasText(this.methodName)) {
			throw new IllegalArgumentException("Property 'methodName' is required");
		}

		Class<?> beanClass = beanFactory.getType(this.targetBeanName);
		if (beanClass == null) {
			throw new IllegalArgumentException("Can't determine type of bean with name '" + this.targetBeanName + "'");
		}
		//在BeanFactoryWare接口的调用中,实现method属性的赋值
		this.method = BeanUtils.resolveSignature(this.methodName, beanClass);

		if (this.method == null) {
			throw new IllegalArgumentException("Unable to locate method [" + this.methodName +
					"] on bean [" + this.targetBeanName + "]");
		}
	}
```



3. AspectJExpressionPointcut  的BD在之前就已被注入，此处根据BD的RunTimeReference去实例化此Bean,并且在注入到AspectJPointcutAdvisor当中去



4. 完成所有AOP核心对象的创建之后，开始创建普通Bean对象.

	resolveBeforeInstation 方法当中如果用户自定义了动态代理的配置，那么targetSource不为空

​     那么就会在此完成动态代理对象的生成

```java 
//如果targetSource为null 则不会在此进行动态代理，主要用于用户自定义的动态代理
		TargetSource targetSource = getCustomTargetSource(beanClass, beanName);
		if (targetSource != null) {
			if (StringUtils.hasLength(beanName)) {
				this.targetSourcedBeans.add(beanName);
			}
			Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);
			Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);
			this.proxyTypes.put(cacheKey, proxy.getClass());
			return proxy;
		}
```



###3.动态代理目标对象

5. 一般在BPP的postAfterIntization()方法之中会完成动态代理对象的生成

	该方法中会遍历所有Advisor类对象，并且会把当前类与所有的Advisor对象匹配 。会传入目标对象的targetClass，以及Advisor的ComposableAdvisor对象，表达式对象中又包含了ClassFileter以及methodMatcher  ，ClassFilter对象就是aspectExpression(引用的表达式对象)，methodMatcher对象中包含了mm1,mm2.其中mm1中包含了method对象   mm2中也是aspectExpression对象

	

	```java 
	//判断,获取切点Bean
			Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
		if (specificInterceptors != DO_NOT_PROXY) {
				this.advisedBeans.put(cacheKey, Boolean.TRUE);
			//创建Bean的代理对象
				Object proxy = createProxy(
						bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
				this.proxyTypes.put(cacheKey, proxy.getClass());
				return proxy;
			}
	\\==========================================================================
	    	protected Object[] getAdvicesAndAdvisorsForBean(
				Class<?> beanClass, String beanName, @Nullable TargetSource targetSource) {
	 //获取之前创建的所有Advisor对象
			List<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);
			if (advisors.isEmpty()) {
				return DO_NOT_PROXY;
			}
			return advisors.toArray();
		}
	\\==========================================================================
	    protected List<Advisor> findAdvisorsThatCanApply(
				List<Advisor> candidateAdvisors, Class<?> beanClass, String beanName) {
	
			ProxyCreationContext.setCurrentProxiedBeanName(beanName);
			try {
				//返回匹配的Advisor对象
				return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);
			}
			finally {
				ProxyCreationContext.setCurrentProxiedBeanName(null);
			}
		}
	\\================================================================================
	    	//遍历所有Advisor，分类匹配advisor
			for (Advisor candidate : candidateAdvisors) {
				if (candidate instanceof IntroductionAdvisor) {
					// already processed
					continue;
				}
				//核心判断是否当前Bean可以跟Advisor对象匹配
				if (canApply(candidate, clazz, hasIntroductions)) {
					eligibleAdvisors.add(candidate);
				}
			}
	\\===============================================================================
	    public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {
			if (advisor instanceof IntroductionAdvisor) {
				return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);
			}
			//一般方法级别的动态代理，进入以下的判断
			else if (advisor instanceof PointcutAdvisor) {
				PointcutAdvisor pca = (PointcutAdvisor) advisor;
				//传入pointCut的AspectExpression对象，AspectExpression对象中包含 methodMather和ClassFilter
				return canApply(pca.getPointcut(), targetClass, hasIntroductions);
			}
			else {
				// It doesn't have a pointcut so we assume it applies.
				return true;
			}
		}
	\\================================================================================
	    
	```
	
	



6. 遍历targetClass的所有Method 

	```java 
	 //遍历targetClass的所有method，调用当前advisor的methodMatcher对象的matches方法
			for (Class<?> clazz : classes) {
				Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);
				for (Method method : methods) {
					if (introductionAwareMethodMatcher != null ?
							introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :
							methodMatcher.matches(method, targetClass)) {
						return true;
					}
				}
			}
	\\=======================
	```

7. 将advisor对象的methodMatcher对象  methodMatcher的 mm1  mm2 与advisor 的method对象进行判断比较  mm1对象是.AbstractAspectJAdvice$AdviceExcludingMethodMatcher   mm2对象是AspectExpression      mm1用于判断advior方法是否与切点表达式方法是同一方法  是则 不代理

	mm2用于判断这个类是否需要被代理  需要则被代理

	```java 
	public boolean matches(Method method, Class<?> targetClass, boolean hasIntroductions) {
	    return (MethodMatchers.matches(this.mm1, method, targetClass, hasIntroductions) &&
	            MethodMatchers.matches(this.mm2, method, targetClass, hasIntroductions));
	}
	\\===============================================================================
	    public static boolean matches(MethodMatcher mm, Method method, Class<?> targetClass, boolean hasIntroductions) {
			Assert.notNull(mm, "MethodMatcher must not be null");
			return (mm instanceof IntroductionAwareMethodMatcher ?
					((IntroductionAwareMethodMatcher) mm).matches(method, targetClass, hasIntroductions) :
					mm.matches(method, targetClass));
		}
	\\================================================================================
	    @Override
			public boolean matches(Method method, Class<?> targetClass) {
	    //判断advisor的method对象是否是表达式的方法，如果是返回false 不是返回true
				return !this.adviceMethod.equals(method);
			}
	
	\\==============================================================================
	    //判断targetClass是否需要被动态代理,如果需要返回true，如果不需要返回false
	    public boolean matches(Method method, Class<?> targetClass, boolean hasIntroductions) {
			obtainPointcutExpression();
			ShadowMatch shadowMatch = getTargetShadowMatch(method, targetClass);
	
			// Special handling for this, target, @this, @target, @annotation
			// in Spring - we can optimize since we know we have exactly this class,
			// and there will never be matching subclass at runtime.
			if (shadowMatch.alwaysMatches()) {
				return true;
			}
			else if (shadowMatch.neverMatches()) {
				return false;
			}
			else {
				// the maybe case
				if (hasIntroductions) {
					return true;
				}
				// A match test returned maybe - if there are any subtype sensitive variables
				// involved in the test (this, target, at_this, at_target, at_annotation) then
				// we say this is not a match as in Spring there will never be a different
				// runtime subtype.
				RuntimeTestWalker walker = getRuntimeTestWalker(shadowMatch);
				return (!walker.testsSubtypeSensitiveVars() || walker.testTargetInstanceOfResidue(targetClass));
			}
		}
	    
	```

	

​     8.在集合当中传入ExposeInvocationInterceptord.ADVISOR对象 通过它的invoke方法，和currentInvocation方法能获取传入MethodInvocation对象

```java 
//传入一个新建的Advisor对象在集合首位，目的是方便获取MethodInvocation对象
		extendAdvisors(eligibleAdvisors);
//==================
protected void extendAdvisors(List<Advisor> candidateAdvisors) {
		AspectJProxyUtils.makeAdvisorChainAspectJCapableIfNecessary(candidateAdvisors);
	}
//=============================================
if (foundAspectJAdvice && !advisors.contains(ExposeInvocationInterceptor.ADVISOR)) {
				advisors.add(0, ExposeInvocationInterceptor.ADVISOR);
				return true;
			}
```



9.运用有向无环图排序所有Advisors

```java 
	eligibleAdvisors = sortAdvisors(eligibleAdvisors);
```



10.开始正式创建代理对象

```java 
Object proxy = createProxy(
    bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
\\==================================================
	protected Object createProxy(Class<?> beanClass, @Nullable String beanName,
			@Nullable Object[] specificInterceptors, TargetSource targetSource) {

		//给目标对象的BD设置一个origalTargetClass的属性
		if (this.beanFactory instanceof ConfigurableListableBeanFactory) {
			AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);
		}

		ProxyFactory proxyFactory = new ProxyFactory();
		proxyFactory.copyFrom(this);

		if (!proxyFactory.isProxyTargetClass()) {
			if (shouldProxyTargetClass(beanClass, beanName)) {
				proxyFactory.setProxyTargetClass(true);
			}
			else {
				//获取目标类的所有接口
				evaluateProxyInterfaces(beanClass, proxyFactory);
			}
		}

		Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
		proxyFactory.addAdvisors(advisors);
		proxyFactory.setTargetSource(targetSource);
		//用于拓展实现
		customizeProxyFactory(proxyFactory);

		proxyFactory.setFrozen(this.freezeProxy);
		if (advisorsPreFiltered()) {
			proxyFactory.setPreFiltered(true);
		}
        //代理对象创建的核心过程
		return proxyFactory.getProxy(getProxyClassLoader());
	}


//=====================================================================
    	public Object getProxy(@Nullable ClassLoader classLoader) {
		return createAopProxy().getProxy(classLoader);
	}

//===========================================================
	protected final synchronized AopProxy createAopProxy() {
		if (!this.active) {
			activate();
		}
        //createAopProxy 选择具体采用jdk动态代理还是cglib动态代理机制
		return getAopProxyFactory().createAopProxy(this);
	}
//===================================================================================
	public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
		if (!NativeDetector.inNativeImage() &&
				(config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) {
			Class<?> targetClass = config.getTargetClass();
			if (targetClass == null) {
				throw new AopConfigException("TargetSource cannot determine target class: " +
						"Either an interface or a target is required for proxy creation.");
			}
			if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
				return new JdkDynamicAopProxy(config);
			}
			return new ObjenesisCglibAopProxy(config);
		}
		else {
			return new JdkDynamicAopProxy(config);
		}
	}
//==========================================================
//JDK动态代理实现  JdkDynamicAopProxy继承InvocationHandler接口
	public Object getProxy(@Nullable ClassLoader classLoader) {
		if (logger.isTraceEnabled()) {
			logger.trace("Creating JDK dynamic proxy: " + this.advised.getTargetSource());
		}
		return Proxy.newProxyInstance(classLoader, this.proxiedInterfaces, this);
	}

//==========================================================
//cglib动态代理实现

	public Object getProxy(@Nullable ClassLoader classLoader) {
		if (logger.isTraceEnabled()) {
			logger.trace("Creating CGLIB proxy: " + this.advised.getTargetSource());
		}

		try {
			Class<?> rootClass = this.advised.getTargetClass();
			Assert.state(rootClass != null, "Target class must be available for creating a CGLIB proxy");

			Class<?> proxySuperClass = rootClass;
			if (rootClass.getName().contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) {
				proxySuperClass = rootClass.getSuperclass();
				Class<?>[] additionalInterfaces = rootClass.getInterfaces();
				for (Class<?> additionalInterface : additionalInterfaces) {
					this.advised.addInterface(additionalInterface);
				}
			}

			// Validate the class, writing log messages as necessary.
			validateClassIfNecessary(proxySuperClass, classLoader);

			// Configure CGLIB Enhancer...
			Enhancer enhancer = createEnhancer();
			if (classLoader != null) {
				enhancer.setClassLoader(classLoader);
				if (classLoader instanceof SmartClassLoader &&
						((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) {
					enhancer.setUseCache(false);
				}
			}
			enhancer.setSuperclass(proxySuperClass);
			enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
			enhancer.setStrategy(new ClassLoaderAwareGeneratorStrategy(classLoader));
            //获取CallBack
			Callback[] callbacks = getCallbacks(rootClass);
			Class<?>[] types = new Class<?>[callbacks.length];
			for (int x = 0; x < types.length; x++) {
				types[x] = callbacks[x].getClass();
			}
			// fixedInterceptorMap only populated at this point, after getCallbacks call above
			enhancer.setCallbackFilter(new ProxyCallbackFilter(
					this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));
			enhancer.setCallbackTypes(types);

			// Generate the proxy class and create a proxy instance.
			return createProxyClassAndInstance(enhancer, callbacks);
		}
		catch (CodeGenerationException | IllegalArgumentException ex) {
			throw new AopConfigException("Could not generate CGLIB subclass of " + this.advised.getTargetClass() +
					": Common causes of this problem include using a final class or a non-visible class",
					ex);
		}
		catch (Throwable ex) {
			// TargetSource.getTarget() failed
			throw new AopConfigException("Unexpected AOP exception", ex);
		}
	}




```

###4.调用动态代理对象的代理方法，责任链模式的调用

11. 当动态代理对象生成完毕，通过责任链模式调用

	1.如果是CigLib方式创建的动态代理对象

	a,调用当前动态代理的this.CGLIB$CALLBACK_0.intercept(代理对象,,,)方法

	```java 
	  public final void wzytargetMethod() {
	        //这里的CGLIB$CALLBACK_0是DynameicAdvior
	        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
	        if (var10000 == null) {
	            CGLIB$BIND_CALLBACKS(this);
	            var10000 = this.CGLIB$CALLBACK_0;
	        }
	
	        if (var10000 != null) {
	            //传入代理对象，代理对象方法，方法参数，MethodProxy对象
	            var10000.intercept(this, CGLIB$wzytargetMethod$0$Method, CGLIB$emptyArgs, CGLIB$wzytargetMethod$0$Proxy);
	        } else {
	            super.wzytargetMethod();
	        }
	    }
	```



 2.DynamicAdvisedInterceptor.intercepter方法

```java 
	public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
			Object oldProxy = null;
			boolean setProxyContext = false;
			Object target = null;
			TargetSource targetSource = this.advised.getTargetSource();
			try {
				if (this.advised.exposeProxy) {
					// Make invocation available if necessary.
					oldProxy = AopContext.setCurrentProxy(proxy);
					setProxyContext = true;
				}
				// Get as late as possible to minimize the time we "own" the target, in case it comes from a pool...
				target = targetSource.getTarget();
				Class<?> targetClass = (target != null ? target.getClass() : null);
				//进行责任链调用
				List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
				Object retVal;
				// Check whether we only have one InvokerInterceptor: that is,
				// no real advice, but just reflective invocation of the target.
				if (chain.isEmpty() && Modifier.isPublic(method.getModifiers())) {
					// We can skip creating a MethodInvocation: just invoke the target directly.
					// Note that the final invoker must be an InvokerInterceptor, so we know
					// it does nothing but a reflective operation on the target, and no hot
					// swapping or fancy proxying.
					Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
					retVal = methodProxy.invoke(target, argsToUse);
				}
				else {
					// We need to create a method invocation...
					retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();
				}
				retVal = processReturnType(proxy, target, method, retVal);
				return retVal;
			}
			finally {
				if (target != null && !targetSource.isStatic()) {
					targetSource.releaseTarget(target);
				}
				if (setProxyContext) {
					// Restore old proxy.
					AopContext.setCurrentProxy(oldProxy);
				}
			}
		}
//==============================================================================
	public List<Object> getInterceptorsAndDynamicInterceptionAdvice(Method method, @Nullable Class<?> targetClass) {
		MethodCacheKey cacheKey = new MethodCacheKey(method);
		List<Object> cached = this.methodCache.get(cacheKey);
		if (cached == null) {
			cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(
					this, method, targetClass);
			this.methodCache.put(cacheKey, cached);
		}
		return cached;
	}
```



3.获取责任链，其顺序为

index初始-1

[0,1,2,3,4,5]

++-1

0 ExposedInterceptor.invoke(cglibProxy)------------>return cglibProxy.proceed();--------->super.processed()



1 AroundInteceptor.invoke(cglibProxy)--------->

return invokeAdviceMethod(pjp, jpm, null, null);------》around方法

System.out.println("我是WzyAspec的aroundMonitor之前的方法");
proceedingJoinPoint.proceed();

return this.methodInvocation.invocableClone().proceed();----->cglibProx.proceed()------>super.proceed()



2.BeforeInterceptorr.invoke(cglibProxy)

this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis()); ------>before()方法
return mi.proceed();---------.cglibProx.proceed()------>super.proceed()





3.AfterInterceptorr.invoke(cglibProxy)

return mi.proceed(); ----->cglibProx.proceed()------>super.proceed()



4.AfterReturnInteceptorr.invoke(cglibProxy)

Object retVal = mi.proceed();----->cglibProx.proceed()------>super.proceed()



5.AfterThrowingInteceptorr.invoke(cglibProxy)

return mi.proceed();----->cglibProx.proceed()------>super.proceed()

if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {

return invokeJoinpoint();

}    ----------->

return this.methodProxy.invoke(this.target, this.arguments);实际就是目标对象的方法



跳出时 5.AfterThrowingInteceptor.invoke(cglibProxy)中mi.proceed之后的方法

如果有异常

catch (Throwable ex) {
			if (shouldInvokeOnThrowing(ex)) {
				invokeAdviceMethod(getJoinPointMatch(), null, ex);
			}
			throw ex;
		}



跳出时 4.AfterReturnInteceptorr.invoke(cglibProxy)中mi.proceed之后的方法  

this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());



跳出时 3.AfterInterceptorr.invoke中(cglibProxy)mi.proceed之后的方法  

invokeAdviceMethod(getJoinPointMatch(), null, null);



跳出时 2.BeforeInterceptorr.invoke(cglibProxy)中mi.proceed之后的方法   无



跳出时 1.AroundInteceptorr.invoke(cglibProxy)中proceedingJoinPoint.proceed()-------->mi.proceed之后的方法  	System.out.println("我是WzyAspec的aroundMonitor之后的方法");



**总结: **

**1.目标方法必定时在通知集合的最后一个元素执行过invoke(this)方法后执行的**

**2.before,around方法，别的的invoke方法里面在调用proceed方法之前，会调用自身的通知方法。完成之后通过proceed方法返回集合链。之后是proceed()返回链之后的方法**

**3.after方法在invoke方法里面首先调用proceed返回链，接着一个finally块调用自身的通知方法。afterThrowing在invoke方法首先调用proceed返回链，接着一个catch块捕捉上一步proceed返回链中的异常，执行自身的通知方法。随后又向外抛出异常**

**4.afterReturn方法首先调用proceed返回链，接着调用自身通知方法**

因此before around-返回链之前的执行顺序，由before,around通知器的位置决定，谁的索引小，谁先执行.

如果afterthrowing在集合的第一位，那么它能捕捉所有异常，包括这些通知中的异常。一旦就异常发生，立即停止。返回afterthrow的proceed返回链，接着运行catch块。注意：after的通知方法是finally块，after通知方法必定会执行.除非没有执行到after的返回链.

因此before around返回链之前的方法 必定最先执行，

其次目标方法.接着没有异常的话，around返回链之后after,afterReturn.谁的索引大谁先执行.

如果有异常的话。afterthrowing索引的位置越小，就能捕捉到索引值大的异常。



MethodBeforeAdviceAdapter------------------》AspectJMethodBeforeAdvice-->MethodBeforeAdviceInterceptor

```java 
public MethodInterceptor getInterceptor(Advisor advisor) {
		MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();
		return new MethodBeforeAdviceInterceptor(advice);
	}
//==================================================
public Object invoke(MethodInvocation mi) throws Throwable {
		this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());
		return mi.proceed();
	}
```





AfterReturningAdviceAdapter------------------》AfterReturningAdvice-------->AfterReturningAdviceInterceptor

```java 
public MethodInterceptor getInterceptor(Advisor advisor) {
		AfterReturningAdvice advice = (AfterReturningAdvice) advisor.getAdvice();
		return new AfterReturningAdviceInterceptor(advice);
	}

//======================================================
public Object invoke(MethodInvocation mi) throws Throwable {
		Object retVal = mi.proceed();
		this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());
		return retVal;
	}
```





ThrowsAdviceAdapter---------------------》ThrowsAdvice------------------>ThrowsAdviceInterceptor

```java 
  public MethodInterceptor getInterceptor(Advisor advisor) {
        return new ThrowsAdviceInterceptor(advisor.getAdvice());
    }
```



ExposeInvocationInterceptor  继承MethodInterceptor接口

```java 
	public Object invoke(MethodInvocation mi) throws Throwable {
		MethodInvocation oldInvocation = invocation.get();
		invocation.set(mi);
		try {
			return mi.proceed();
		}
		finally {
			invocation.set(oldInvocation);
		}
	}
```



AspectJMethodBeforeAdvice

```java 

```



AspectJMethodAfterReturnAdvice  

```java 

```



AspectJMethodAfterAdvice  继承MethodInterceptor接口

```java 
	public Object invoke(MethodInvocation mi) throws Throwable {
		try {
			return mi.proceed();
		}
		finally {
			invokeAdviceMethod(getJoinPointMatch(), null, null);
		}
	}
```



AspectJMethodAfterThrowingAdvice  继承MethodInterceptor接口

```java 
	public Object invoke(MethodInvocation mi) throws Throwable {
		try {
			return mi.proceed();
		}
		catch (Throwable ex) {
			if (shouldInvokeOnThrowing(ex)) {
				invokeAdviceMethod(getJoinPointMatch(), null, ex);
			}
			throw ex;
		}
	}
```



AspectJMethodAroundrAdvice 继承MethodInterceptor接口



```
public Object invoke(MethodInvocation mi) throws Throwable {
if (!(mi instanceof ProxyMethodInvocation)) {
throw new IllegalStateException("MethodInvocation is not a Spring ProxyMethodInvocation: " + mi);
}
ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;
ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);
JoinPointMatch jpm = getJoinPointMatch(pmi);
return invokeAdviceMethod(pjp, jpm, null, null);
} 



//===============================================================================
protected Object invokeAdviceMethod(JoinPoint jp, @Nullable JoinPointMatch jpMatch,
@Nullable Object returnValue, @Nullable Throwable t) throws Throwable {

return invokeAdviceMethodWithGivenArgs(argBinding(jp, jpMatch, returnValue, t));
}

//========================================
protected Object invokeAdviceMethodWithGivenArgs(Object[] args) throws Throwable {
		Object[] actualArgs = args;
		if (this.aspectJAdviceMethod.getParameterCount() == 0) {
			actualArgs = null;
		}
		try {
			ReflectionUtils.makeAccessible(this.aspectJAdviceMethod);
			return this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs);
		}
		catch (IllegalArgumentException ex) {
			throw new AopInvocationException("Mismatch on arguments to advice method [" +
					this.aspectJAdviceMethod + "]; pointcut expression [" +
					this.pointcut.getPointcutExpression() + "]", ex);
		}
		catch (InvocationTargetException ex) {
			throw ex.getTargetException();
		}
	}
```



#### 5.注解方式的AOP

####1.ConfirguationPostProceesor BD的注入

```java 
AnnotationConfigApplicationContext applicationContext=new AnnotationConfigApplicationContext();

//===========================================================================
public AnnotationConfigApplicationContext() {
		StartupStep createAnnotatedBeanDefReader = this.getApplicationStartup().start("spring.context.annotated-bean-reader.create");
		this.reader = new AnnotatedBeanDefinitionReader(this);
		createAnnotatedBeanDefReader.end();
		this.scanner = new ClassPathBeanDefinitionScanner(this);
	}
//===================================================================================
	public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) {
		this(registry, getOrCreateEnvironment(registry));
	}
//==================================================================
	public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {
		Assert.notNull(registry, "BeanDefinitionRegistry must not be null");
		Assert.notNull(environment, "Environment must not be null");
		this.registry = registry;
		this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);
        //和xml配置一样注册几个Inner BPP的BD到工厂中去
		AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
	}
```



#### 2.如果是注解的话@EnableAspectJAutoProxy

通过@EnableAspectJAutoProxy的 @Import(AspectJAutoProxyRegistrar.class)  collectImport 这个AspectJAutoProxyRegistrar类，之后再通过 this.reader.loadBD()方法 将AnnotationAwareAspectJAutoProxyCreator 注册到工厂之中。

```java 
	public void registerBeanDefinitions(
			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

		AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);

		AnnotationAttributes enableAspectJAutoProxy =
				AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);
		if (enableAspectJAutoProxy != null) {
			if (enableAspectJAutoProxy.getBoolean("proxyTargetClass")) {
				AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
			}
			if (enableAspectJAutoProxy.getBoolean("exposeProxy")) {
				AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
			}
		}
	}
```



#### 3.将AOP  AnnotationAwareAspectJAutoProxyCreator 的BD注册到工厂之后，处理的方式和xml的逻辑一样.





# Spring事务

### 1.spring事务的准备工作（依赖spring的AOP）

1. <aop:config>标签的解析，构建AspectJExpressionPointcut类的BD，构建DefaultBeanFactoryPointcutAdvisor类的BD注册到工厂，并且跟AOP一样有AspectJAwareAutoProxyCreator核心BD

```Java 
//如果是<aop:config>下的<aop:pointcut>的标签的话，构建AspectJExpressionPointcut类的BD
if (POINTCUT.equals(localName)) {
    parsePointcut(elt, parserContext);
}
//如果是<aop:config>下的<aop:advisor>的标签的话,构建DefaultBeanFactoryPointcutAdvisor类的BD
else if (ADVISOR.equals(localName)) {
    parseAdvisor(elt, parserContext);
}
```



2. <tx:advisor>标签的解析，交给TxNamespaceHandler解析，里面有TxAdviceBeanDefinitionParser解析该标签  ,构建一个TransactionInterceptor.class类的BD注册到工厂

	```java 
	Class<?> beanClass = getBeanClass(element);
	//=====================================
	protected Class<?> getBeanClass(Element element) {
	    return TransactionInterceptor.class;
	}
	//===================================
	protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
	    //给TransactionInterceptor类的BD设置transactionManager属性。属性值是RunTimeReference
	    builder.addPropertyReference("transactionManager", TxNamespaceHandler.getTransactionManagerName(element));
	
	    List<Element> txAttributes = DomUtils.getChildElementsByTagName(element, ATTRIBUTES_ELEMENT);
	    if (txAttributes.size() > 1) {
	        parserContext.getReaderContext().error(
	            "Element <attributes> is allowed at most once inside element <advice>", element);
	    }
	    else if (txAttributes.size() == 1) {
	        // Using attributes source.
	        Element attributeSourceElement = txAttributes.get(0);
	        //解析<tx:attributes>标签的子标签<tx:method>
	        RootBeanDefinition attributeSourceDefinition = parseAttributeSource(attributeSourceElement, parserContext);
	        //将<tx:attributes>标签转化为BD并且填充到ransactionInterceptor类的BD的transactionAttributeSource属性
	        builder.addPropertyValue("transactionAttributeSource", attributeSourceDefinition);
	    }
	    else {
	        // Assume annotations source.
	        builder.addPropertyValue("transactionAttributeSource",
	                                 new RootBeanDefinition("org.springframework.transaction.annotation.AnnotationTransactionAttributeSource"));
	    }
	}
	//================================================================================
	private RootBeanDefinition parseAttributeSource(Element attrEle, ParserContext parserContext) {
			List<Element> methods = DomUtils.getChildElementsByTagName(attrEle, METHOD_ELEMENT);
			ManagedMap<TypedStringValue, RuleBasedTransactionAttribute> transactionAttributeMap =
					new ManagedMap<>(methods.size());
			transactionAttributeMap.setSource(parserContext.extractSource(attrEle));
	        //循环解析<tx:attributes>子标签<tx:method>
			for (Element methodEle : methods) {
				//获取name属性值
				String name = methodEle.getAttribute(METHOD_NAME_ATTRIBUTE);
				TypedStringValue nameHolder = new TypedStringValue(name);
				nameHolder.setSource(parserContext.extractSource(methodEle));
	
				RuleBasedTransactionAttribute attribute = new RuleBasedTransactionAttribute();
				//获取propagation属性值
				String propagation = methodEle.getAttribute(PROPAGATION_ATTRIBUTE);
				//获取isolation属性值
				String isolation = methodEle.getAttribute(ISOLATION_ATTRIBUTE);
				//获取timeout属性值
				String timeout = methodEle.getAttribute(TIMEOUT_ATTRIBUTE);
				//获取read_only属性值
				String readOnly = methodEle.getAttribute(READ_ONLY_ATTRIBUTE);
				if (StringUtils.hasText(propagation)) {
					attribute.setPropagationBehaviorName(RuleBasedTransactionAttribute.PREFIX_PROPAGATION + propagation);
				}
				if (StringUtils.hasText(isolation)) {
					attribute.setIsolationLevelName(RuleBasedTransactionAttribute.PREFIX_ISOLATION + isolation);
				}
				if (StringUtils.hasText(timeout)) {
					attribute.setTimeoutString(timeout);
				}
				if (StringUtils.hasText(readOnly)) {
					attribute.setReadOnly(Boolean.parseBoolean(methodEle.getAttribute(READ_ONLY_ATTRIBUTE)));
				}
	
				List<RollbackRuleAttribute> rollbackRules = new ArrayList<>(1);
				//获取rollback_for属性值
				if (methodEle.hasAttribute(ROLLBACK_FOR_ATTRIBUTE)) {
					String rollbackForValue = methodEle.getAttribute(ROLLBACK_FOR_ATTRIBUTE);
					addRollbackRuleAttributesTo(rollbackRules, rollbackForValue);
				}
				//获取no_rollback_for属性值
				if (methodEle.hasAttribute(NO_ROLLBACK_FOR_ATTRIBUTE)) {
					String noRollbackForValue = methodEle.getAttribute(NO_ROLLBACK_FOR_ATTRIBUTE);
					addNoRollbackRuleAttributesTo(rollbackRules, noRollbackForValue);
				}
				//设置rollbackRules属性
				attribute.setRollbackRules(rollbackRules);
	
				transactionAttributeMap.put(nameHolder, attribute);
			}
	
			RootBeanDefinition attributeSourceDefinition = new RootBeanDefinition(NameMatchTransactionAttributeSource.class);
			attributeSourceDefinition.setSource(parserContext.extractSource(attrEle));
			//将<tx:arrtrbute>子标签的值都转化为一个map放入TransactionInterceptor类BD的nameMap属性当中
			attributeSourceDefinition.getPropertyValues().add("nameMap", transactionAttributeMap);
			return attributeSourceDefinition;
		}
	```





### 2.Spring事务核心Bean的创建

1. registerBPP阶段注入AspectJAwareAutoProxyCreator Bean

2. 非advior对象resloveBeforeInsationBeanPostProceessor中的AspectJAwareAutoProxyCreator

	的shouldSkip() 正式实例化DefaultBeanFactoryPointcutAdvisor,此过程会因为依赖注入实例化

	AspectPointCutExpression  getBean RuntimeBeanReference (会直接实例化Bean) 

	advisedBean  getBean RuntimeBeanNameReference  (设置BeanName,不会实例化Bean) 

	```java 
	public List<Advisor> findAdvisorBeans() {
			// Determine list of advisor bean names, if not cached already.
			//获取之前缓存的AOP的BeanName
			String[] advisorNames = this.cachedAdvisorBeanNames;
			if (advisorNames == null) {
				// Do not initialize FactoryBeans here: We need to leave all regular beans
				// uninitialized to let the auto-proxy creator apply to them!
				//从BeanFactory当中获取所有Advisor接口实现类的BeanName
				advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
						this.beanFactory, Advisor.class, true, false);
				this.cachedAdvisorBeanNames = advisorNames;
			}
			if (advisorNames.length == 0) {
				return new ArrayList<>();
			}
	
			List<Advisor> advisors = new ArrayList<>();
			//遍历advior实现类的BeanNAME 并且进行实例化
			for (String name : advisorNames) {
				if (isEligibleBean(name)) {
					if (this.beanFactory.isCurrentlyInCreation(name)) {
						if (logger.isTraceEnabled()) {
							logger.trace("Skipping currently created advisor '" + name + "'");
						}
					}
					else {
						try {
							//正式开始实例化Advisor实现类Bean 并且完成后加入缓存
							advisors.add(this.beanFactory.getBean(name, Advisor.class));
						}
						catch (BeanCreationException ex) {
							Throwable rootCause = ex.getMostSpecificCause();
							if (rootCause instanceof BeanCurrentlyInCreationException) {
								BeanCreationException bce = (BeanCreationException) rootCause;
								String bceBeanName = bce.getBeanName();
								if (bceBeanName != null && this.beanFactory.isCurrentlyInCreation(bceBeanName)) {
									if (logger.isTraceEnabled()) {
										logger.trace("Skipping advisor '" + name +
												"' with dependency on currently created bean: " + ex.getMessage());
									}
									// Ignore: indicates a reference back to the bean we're trying to advise.
									// We want to find advisors other than the currently created bean itself.
									continue;
								}
							}
							throw ex;
						}
					}
				}
			}
			return advisors;
		}
	```

	



3. advice对象的创建

	在创建动态代理对象获取对应advisor的时候，会有一步判断，在判断的getAdvice()里面会根据advisedBeanName来创建advice，并且将之赋值给DefaultBeanFactoryAdvisor的advice属性.

	至此，事务的核心对象已经创建完毕。进行下一步调用。

	**注意此advice也实现了MethodInceptor接口，所以里面有interceptor方法**

	```java 
	protected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {
	    //获取之前创建好的所有Advisor对象
	    List<Advisor> candidateAdvisors = findCandidateAdvisors();
	    //遍历所有Advisor对象，找到匹配的Advisor对象
	    List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
	    //传入一个新建的Advisor对象在集合首位，目的是方便获取MethodInvocation对象
	    extendAdvisors(eligibleAdvisors);
	    if (!eligibleAdvisors.isEmpty()) {
	        eligibleAdvisors = sortAdvisors(eligibleAdvisors);
	    }
	    return eligibleAdvisors;
	}
	//========================================================================
	protected void extendAdvisors(List<Advisor> candidateAdvisors) {
	    AspectJProxyUtils.makeAdvisorChainAspectJCapableIfNecessary(candidateAdvisors);
	}
	
	//============================================================================
	public static boolean makeAdvisorChainAspectJCapableIfNecessary(List<Advisor> advisors) {
	    // Don't add advisors to an empty list; may indicate that proxying is just not required
	    if (!advisors.isEmpty()) {
	        boolean foundAspectJAdvice = false;
	        for (Advisor advisor : advisors) {
	            // Be careful not to get the Advice without a guard, as this might eagerly
	            // instantiate a non-singleton AspectJ aspect...
	            //注意此处里面会调用事务DefaultBeanFactoryPointcutAdvisor实现类的getAdvice方法实例化advice
	            if (isAspectJAdvice(advisor)) {
	                foundAspectJAdvice = true;
	                break;
	            }
	        }
	        if (foundAspectJAdvice && !advisors.contains(ExposeInvocationInterceptor.ADVISOR)) {
	            advisors.add(0, ExposeInvocationInterceptor.ADVISOR);
	            return true;
	        }
	    }
	    return false;
	}
	//================================================================================
	private static boolean isAspectJAdvice(Advisor advisor) {
	    //事务advisor会调用getAdvice 实例化自己的advice对象，并且填充属性
	    return (advisor instanceof InstantiationModelAwarePointcutAdvisor ||
	            advisor.getAdvice() instanceof AbstractAspectJAdvice ||
	            (advisor instanceof PointcutAdvisor &&
	             ((PointcutAdvisor) advisor).getPointcut() instanceof AspectJExpressionPointcut));
	}
	//=============================================================================
	public Advice getAdvice() {
	    Advice advice = this.advice;
	    if (advice != null) {
	        return advice;
	    }
	
	    Assert.state(this.adviceBeanName != null, "'adviceBeanName' must be specified");
	    Assert.state(this.beanFactory != null, "BeanFactory must be set to resolve 'adviceBeanName'");
	    //事务的advisor对象的adviceBeanName此处是有值的，并且工厂中是含有BD的，因此advice对象会在此实例化
	    if (this.beanFactory.isSingleton(this.adviceBeanName)) {
	        // Rely on singleton semantics provided by the factory.
	        advice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);
	        //事务的advior 的advice属性会在此赋值
	        this.advice = advice;
	        return advice;
	    }
	    else {
	        // No singleton guarantees from the factory -> let's lock locally but
	        // reuse the factory's singleton lock, just in case a lazy dependency
	        // of our advice bean happens to trigger the singleton lock implicitly...
	        synchronized (this.adviceMonitor) {
	            advice = this.advice;
	            if (advice == null) {
	                advice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);
	                this.advice = advice;
	            }
	            return advice;
	        }
	    }
	}
	
	```

	

### 3.Spring事务注解方式配置方式

 #### 1.BD准备阶段

1. 解析@EnableTransactionManagement 的@Import注解里面包含TransactionManagementConfigurationSelector.class ，此类注册了两个BD，一个AutoProxyRegistrar.class实现了ImportSelectorRegister接口.

一个ProxyTransactionManagementConfiguration 是@Configuration配置类.

```java 
public final String[] selectImports(AnnotationMetadata importingClassMetadata) {
		Class<?> annType = GenericTypeResolver.resolveTypeArgument(getClass(), AdviceModeImportSelector.class);
		Assert.state(annType != null, "Unresolvable type argument for AdviceModeImportSelector");

		AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(importingClassMetadata, annType);
		if (attributes == null) {
			throw new IllegalArgumentException(String.format(
					"@%s is not present on importing class '%s' as expected",
					annType.getSimpleName(), importingClassMetadata.getClassName()));
		}

		AdviceMode adviceMode = attributes.getEnum(getAdviceModeAttributeName());
		String[] imports = selectImports(adviceMode);
		if (imports == null) {
			throw new IllegalArgumentException("Unknown AdviceMode: " + adviceMode);
		}
		return imports;
	}
//============================================================	
protected String[] selectImports(AdviceMode adviceMode) {
		switch (adviceMode) {
			case PROXY:
				return new String[] {AutoProxyRegistrar.class.getName(),
						ProxyTransactionManagementConfiguration.class.getName()};
			case ASPECTJ:
				return new String[] {determineTransactionAspectClass()};
			default:
				return null;
		}
	}
```



2.  AutoProxyRegistrar 会用registerBeanDefinition方法注册InfrastructureAdvisorAutoProxyCreator.class BD

```java 
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
    boolean candidateFound = false;
    Set<String> annTypes = importingClassMetadata.getAnnotationTypes();
    for (String annType : annTypes) {
        AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annType);
        if (candidate == null) {
            continue;
        }
        Object mode = candidate.get("mode");
        Object proxyTargetClass = candidate.get("proxyTargetClass");
        if (mode != null && proxyTargetClass != null && AdviceMode.class == mode.getClass() &&
            Boolean.class == proxyTargetClass.getClass()) {
            candidateFound = true;
            if (mode == AdviceMode.PROXY) {
                AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);
                if ((Boolean) proxyTargetClass) {
                    AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
                    return;
                }
            }
        }
    }
    if (!candidateFound && logger.isInfoEnabled()) {
        String name = getClass().getSimpleName();
        logger.info(String.format("%s was imported but no annotations were found " +
                                  "having both 'mode' and 'proxyTargetClass' attributes of type " +
                                  "AdviceMode and boolean respectively. This means that auto proxy " +
                                  "creator registration and configuration may not have occurred as " +
                                  "intended, and components may not be proxied as expected. Check to " +
                                  "ensure that %s has been @Import'ed on the same class where these " +
                                  "annotations are declared; otherwise remove the import of %s " +
                                  "altogether.", name, name, name));
    }
}
//===============================================================
public static BeanDefinition registerAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry) {
    return registerAutoProxyCreatorIfNecessary(registry, null);
}
//====================================================================
public static BeanDefinition registerAutoProxyCreatorIfNecessary(
    BeanDefinitionRegistry registry, @Nullable Object source) {

    return registerOrEscalateApcAsRequired(InfrastructureAdvisorAutoProxyCreator.class, registry, source);
}
```

3. ProxyTransactionManagementConfiguration 配置类也会注册BD

	```java 
	@Configuration(proxyBeanMethods = false)
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	public class ProxyTransactionManagementConfiguration extends AbstractTransactionManagementConfiguration {
	
		@Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)
		@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
		public BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor(
				TransactionAttributeSource transactionAttributeSource, TransactionInterceptor transactionInterceptor) {
	
			BeanFactoryTransactionAttributeSourceAdvisor advisor = new BeanFactoryTransactionAttributeSourceAdvisor();
			advisor.setTransactionAttributeSource(transactionAttributeSource);
			advisor.setAdvice(transactionInterceptor);
			if (this.enableTx != null) {
				advisor.setOrder(this.enableTx.<Integer>getNumber("order"));
			}
			return advisor;
		}
	
		@Bean
		@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
		public TransactionAttributeSource transactionAttributeSource() {
			return new AnnotationTransactionAttributeSource();
		}
	
		@Bean
		@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
		public TransactionInterceptor transactionInterceptor(TransactionAttributeSource transactionAttributeSource) {
			TransactionInterceptor interceptor = new TransactionInterceptor();
			interceptor.setTransactionAttributeSource(transactionAttributeSource);
			if (this.txManager != null) {
				interceptor.setTransactionManager(this.txManager);
			}
			return interceptor;
		}
	
	}
	```

	



#### 2.注解核心对象的创建

**所有@Configuration修饰，并且含有full 属性Attribute的配置类都会在ConfigurationClassPostPocessor的posssAfterBeanFactory方法中被设置为需要代理的BD，之后再工厂实例化的过程中也会被动态代理**

1. 在对象的创建过程中会调用applyAfterPostProcessor方法，该方法会遍历执行所有的BeanPostProecessor的后置增强方法。其中有一个就是InfrastructureAdvisorAutoProxyCreator  如果是需要动态代理的对象，那么再经过此类的后置增强方法中，就会寻找创建advisor，并且执行创建有关advisor的一系列核心对象。包括

BeanFactoryTransactionAttributeSourceAdvisor，TransactionInterceptor，TransactionAttributeSource。

其中BeanFactoryTransactionAttributeSourceAdvisor的 findAdvisorsThatCanApply 会调用AopUtil的canApply方法最终会调用到TransactionAttributeSource（实际是AnnotationTransactionAttributeSource  继承AbstractFallbackTransactionAttributeSource）的getTransactionAttribute方法 判断是否@Transactional方法，并且判断目标类的方式是否与Advisor匹配。如果匹配直接加入advisor当中

```java 
Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
//================================================
	protected Object[] getAdvicesAndAdvisorsForBean(
			Class<?> beanClass, String beanName, @Nullable TargetSource targetSource) {
        //获取之前创建的所有Advisor对象
		List<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);
		if (advisors.isEmpty()) {
			return DO_NOT_PROXY;
		}
		return advisors.toArray();
	}
//===============================================================
protected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {
		//获取之前创建好的所有Advisor对象
		List<Advisor> candidateAdvisors = findCandidateAdvisors();
		//遍历所有Advisor对象，找到匹配的Advisor对象
		List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
		//传入一个新建的Advisor对象在集合首位，目的是方便获取MethodInvocation对象
		extendAdvisors(eligibleAdvisors);
		if (!eligibleAdvisors.isEmpty()) {
			eligibleAdvisors = sortAdvisors(eligibleAdvisors);
		}
		return eligibleAdvisors;
	}
//=========================================================================
protected List<Advisor> findAdvisorsThatCanApply(
			List<Advisor> candidateAdvisors, Class<?> beanClass, String beanName) {

		ProxyCreationContext.setCurrentProxiedBeanName(beanName);
		try {
			//返回匹配的Advisor对象
			return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);
		}
		finally {
			ProxyCreationContext.setCurrentProxiedBeanName(null);
		}
	}
//===============================================================================
public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {
		//如果advisors集合为空，直接退出不做处理。
		if (candidateAdvisors.isEmpty()) {
			return candidateAdvisors;
		}
		List<Advisor> eligibleAdvisors = new ArrayList<>();
		//将IntroductionAdvisor类的Bean单独存放至一个集合里面
		for (Advisor candidate : candidateAdvisors) {
			if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {
				eligibleAdvisors.add(candidate);
			}
		}
		//判断是否有IntroductionAdvisor类的Bean
		boolean hasIntroductions = !eligibleAdvisors.isEmpty();

		//遍历所有Advisor，分类匹配advisor
		for (Advisor candidate : candidateAdvisors) {
			if (candidate instanceof IntroductionAdvisor) {
				// already processed
				continue;
			}
			//核心判断是否当前Bean可以跟Advisor对象匹配
			if (canApply(candidate, clazz, hasIntroductions)) {
				eligibleAdvisors.add(candidate);
			}
		}
		return eligibleAdvisors;
	}
//==============================================================================
public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {
		if (advisor instanceof IntroductionAdvisor) {
			return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);
		}
		//一般方法级别的动态代理，进入以下的判断
		else if (advisor instanceof PointcutAdvisor) {
			PointcutAdvisor pca = (PointcutAdvisor) advisor;
			//传入pointCut的AspectExpression对象，AspectExpression对象中包含 methodMather和ClassFilter
			return canApply(pca.getPointcut(), targetClass, hasIntroductions);
		}
		else {
			// It doesn't have a pointcut so we assume it applies.
			return true;
		}
	}
//====================================================
	public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {
		Assert.notNull(pc, "Pointcut must not be null");
		if (!pc.getClassFilter().matches(targetClass)) {
			return false;
		}

		MethodMatcher methodMatcher = pc.getMethodMatcher();
		if (methodMatcher == MethodMatcher.TRUE) {
			// No need to iterate the methods if we're matching any method anyway...
			return true;
		}

		IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;
		if (methodMatcher instanceof IntroductionAwareMethodMatcher) {
			introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;
		}

		Set<Class<?>> classes = new LinkedHashSet<>();
		if (!Proxy.isProxyClass(targetClass)) {
			classes.add(ClassUtils.getUserClass(targetClass));
		}
		classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));
       //遍历targetClass的所有method，调用当前advisor的methodMatcher对象的matches方法
		for (Class<?> clazz : classes) {
			Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);
			for (Method method : methods) {
				if (introductionAwareMethodMatcher != null ?
						introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :
						methodMatcher.matches(method, targetClass)) {
					return true;
				}
			}
		}

		return false;
	}
//===============================================
public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class<?> targetClass) {
		if (method.getDeclaringClass() == Object.class) {
			return null;
		}

		// First, see if we have a cached value.
		Object cacheKey = getCacheKey(method, targetClass);
		TransactionAttribute cached = this.attributeCache.get(cacheKey);
		if (cached != null) {
			// Value will either be canonical value indicating there is no transaction attribute,
			// or an actual transaction attribute.
			if (cached == NULL_TRANSACTION_ATTRIBUTE) {
				return null;
			}
			else {
				return cached;
			}
		}
		else {
			// We need to work it out.
			TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);
			// Put it in the cache.
			if (txAttr == null) {
				this.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);
			}
			else {
				String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);
				if (txAttr instanceof DefaultTransactionAttribute) {
					DefaultTransactionAttribute dta = (DefaultTransactionAttribute) txAttr;
					dta.setDescriptor(methodIdentification);
					dta.resolveAttributeStrings(this.embeddedValueResolver);
				}
				if (logger.isTraceEnabled()) {
					logger.trace("Adding transactional method '" + methodIdentification + "' with attribute: " + txAttr);
				}
				this.attributeCache.put(cacheKey, txAttr);
			}
			return txAttr;
		}
	}

```



#### 3.Spring事务的处理流

1. 入责任链调用  DynamicAdvisedInterceptor  
2. ExposedInvocationInterceptor 转入 TransactionInteceptor调用

```java 
public Object invoke(MethodInvocation invocation) throws Throwable {
		// Work out the target class: may be {@code null}.
		// The TransactionAttributeSource should be passed the target class
		// as well as the method, which may be from an interface.
		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);

		// Adapt to TransactionAspectSupport's invokeWithinTransaction...
		return invokeWithinTransaction(invocation.getMethod(), targetClass, new CoroutinesInvocationCallback() {
			@Override
			@Nullable
			public Object proceedWithInvocation() throws Throwable {
				return invocation.proceed();
			}
			@Override
			public Object getTarget() {
				return invocation.getThis();
			}
			@Override
			public Object[] getArguments() {
				return invocation.getArguments();
			}
		});
	}
```



**TransactionInteceptor的Invoke核心处理流程**

1. 获取TxAttribute 以及TransactionManager
2. 第一次TransactionInfo 不存在，则getTransaction() 创建初始化。他的TransactionStatus 为newTransaction

```java 
protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,
			@Nullable TransactionAttribute txAttr, final String joinpointIdentification) {

		// If no name specified, apply method identification as transaction name.
		if (txAttr != null && txAttr.getName() == null) {
			txAttr = new DelegatingTransactionAttribute(txAttr) {
				@Override
				public String getName() {
					return joinpointIdentification;
				}
			};
		}

		TransactionStatus status = null;
		if (txAttr != null) {
			if (tm != null) {
				status = tm.getTransaction(txAttr);
			}
			else {
				if (logger.isDebugEnabled()) {
					logger.debug("Skipping transactional joinpoint [" + joinpointIdentification +
							"] because no transaction manager has been configured");
				}
			}
		}
		return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
	}
```



3. 创建事务的过程中，获取事务状态。里面根据事务的传播特性。决定了事务不同的逻辑

	如果是独立事务怎么进行，如果是嵌套事务，如何根据隔离级别进行事务的控制

```java 
	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition)
			throws TransactionException {

		// Use defaults if no transaction definition given.
		TransactionDefinition def = (definition != null ? definition : TransactionDefinition.withDefaults());

		Object transaction = doGetTransaction();
		boolean debugEnabled = logger.isDebugEnabled();

		//判断当前是否已经存在事务，如果存在直接走下面的逻辑
		if (isExistingTransaction(transaction)) {
			// Existing transaction found -> check propagation behavior to find out how to behave.
			return handleExistingTransaction(def, transaction, debugEnabled);
		}

		//当前不存在事务，走下面的逻辑
		// Check definition settings for new transaction.
		if (def.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {
			throw new InvalidTimeoutException("Invalid transaction timeout", def.getTimeout());
		}

		// No existing transaction found -> check propagation behavior to find out how to proceed.
		if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {
			throw new IllegalTransactionStateException(
					"No existing transaction found for transaction marked with propagation 'mandatory'");
		}
		else if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||
				def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||
				def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
			SuspendedResourcesHolder suspendedResources = suspend(null);
			if (debugEnabled) {
				logger.debug("Creating new transaction with name [" + def.getName() + "]: " + def);
			}
			try {
				//开启一个事务
				return startTransaction(def, transaction, debugEnabled, suspendedResources);
			}
			catch (RuntimeException | Error ex) {
				resume(null, suspendedResources);
				throw ex;
			}
		}
		else {
			// Create "empty" transaction: no actual transaction, but potentially synchronization.
			if (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {
				logger.warn("Custom isolation level specified but no actual transaction initiated; " +
						"isolation level will effectively be ignored: " + def);
			}
			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
			return prepareTransactionStatus(def, null, true, newSynchronization, debugEnabled, null);
		}
	}
```





4. 将当前事务对象绑定到当前线程，也就是向ThreadLocal存入。并且设置外层事务对象（如果有的话）。保护现场。

```java 
private void bindToThread() {
			// Expose current TransactionStatus, preserving any existing TransactionStatus
			// for restoration after this transaction is complete.
			this.oldTransactionInfo = transactionInfoHolder.get();
			transactionInfoHolder.set(this);
		}
```





5.事务对象准备完毕之后commitTransactionAfterReturning（），提交SQL

```java 
 //独立的事务，提交事务的方法
			commitTransactionAfterReturning(txInfo);
//===========================
protected void commitTransactionAfterReturning(@Nullable TransactionInfo txInfo) {
		if (txInfo != null && txInfo.getTransactionStatus() != null) {
			if (logger.isTraceEnabled()) {
				logger.trace("Completing transaction for [" + txInfo.getJoinpointIdentification() + "]");
			}
			txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
		}
	}
//==============================================================
	public final void commit(TransactionStatus status) throws TransactionException {
		if (status.isCompleted()) {
			throw new IllegalTransactionStateException(
					"Transaction is already completed - do not call commit or rollback more than once per transaction");
		}

		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;
		if (defStatus.isLocalRollbackOnly()) {
			if (defStatus.isDebug()) {
				logger.debug("Transactional code has requested rollback");
			}
			processRollback(defStatus, false);
			return;
		}

		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {
			if (defStatus.isDebug()) {
				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit");
			}
			processRollback(defStatus, true);
			return;
		}
        //提交事务
		processCommit(defStatus);
	}
//===========================================================================
	private void processCommit(DefaultTransactionStatus status) throws TransactionException {
		try {
			boolean beforeCompletionInvoked = false;

			try {
				boolean unexpectedRollback = false;
				prepareForCommit(status);
				triggerBeforeCommit(status);
				triggerBeforeCompletion(status);
				beforeCompletionInvoked = true;

				if (status.hasSavepoint()) {
					if (status.isDebug()) {
						logger.debug("Releasing transaction savepoint");
					}
					unexpectedRollback = status.isGlobalRollbackOnly();
					status.releaseHeldSavepoint();
				}
				else if (status.isNewTransaction()) {
					if (status.isDebug()) {
						logger.debug("Initiating transaction commit");
					}
					unexpectedRollback = status.isGlobalRollbackOnly();
					doCommit(status);
				}
				else if (isFailEarlyOnGlobalRollbackOnly()) {
					unexpectedRollback = status.isGlobalRollbackOnly();
				}

				// Throw UnexpectedRollbackException if we have a global rollback-only
				// marker but still didn't get a corresponding exception from commit.
				if (unexpectedRollback) {
					throw new UnexpectedRollbackException(
							"Transaction silently rolled back because it has been marked as rollback-only");
				}
			}
			catch (UnexpectedRollbackException ex) {
				// can only be caused by doCommit
				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);
				throw ex;
			}
			catch (TransactionException ex) {
				// can only be caused by doCommit
				if (isRollbackOnCommitFailure()) {
					doRollbackOnCommitException(status, ex);
				}
				else {
					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
				}
				throw ex;
			}
			catch (RuntimeException | Error ex) {
				if (!beforeCompletionInvoked) {
					triggerBeforeCompletion(status);
				}
				doRollbackOnCommitException(status, ex);
				throw ex;
			}

			// Trigger afterCommit callbacks, with an exception thrown there
			// propagated to callers but the transaction still considered as committed.
			try {
				triggerAfterCommit(status);
			}
			finally {
				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);
			}

		}
		finally {
			cleanupAfterCompletion(status);
		}
	}
//=============================================================================
	protected void doCommit(DefaultTransactionStatus status) {
		DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();
		Connection con = txObject.getConnectionHolder().getConnection();
		if (status.isDebug()) {
			logger.debug("Committing JDBC transaction on Connection [" + con + "]");
		}
		try {
			con.commit();
		}
		catch (SQLException ex) {
			throw translateException("JDBC commit", ex);
		}
	}
```



6.事务方法出现异常的话，回滚事务 completeTransactionAfterThrowing(txInfo, ex);

```java 
protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) {
		if (txInfo != null && txInfo.getTransactionStatus() != null) {
			if (logger.isTraceEnabled()) {
				logger.trace("Completing transaction for [" + txInfo.getJoinpointIdentification() +
						"] after exception: " + ex);
			}
			if (txInfo.transactionAttribute != null && txInfo.transactionAttribute.rollbackOn(ex)) {
				try {
					txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());
				}
				catch (TransactionSystemException ex2) {
					logger.error("Application exception overridden by rollback exception", ex);
					ex2.initApplicationException(ex);
					throw ex2;
				}
				catch (RuntimeException | Error ex2) {
					logger.error("Application exception overridden by rollback exception", ex);
					throw ex2;
				}
			}
			else {
				// We don't roll back on this exception.
				// Will still roll back if TransactionStatus.isRollbackOnly() is true.
				try {
					txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
				}
				catch (TransactionSystemException ex2) {
					logger.error("Application exception overridden by commit exception", ex);
					ex2.initApplicationException(ex);
					throw ex2;
				}
				catch (RuntimeException | Error ex2) {
					logger.error("Application exception overridden by commit exception", ex);
					throw ex2;
				}
			}
		}
	}

//===================================================================
	protected void doRollback(DefaultTransactionStatus status) {
		DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();
		Connection con = txObject.getConnectionHolder().getConnection();
		if (status.isDebug()) {
			logger.debug("Rolling back JDBC transaction on Connection [" + con + "]");
		}
		try {
			con.rollback();
		}
		catch (SQLException ex) {
			throw translateException("JDBC rollback", ex);
		}
	}
//==================================================================================



```





### 4.Spring事务的传播特性组合

**前置事务的传播特性知识**

Required:支持外层事务，如果没有的话，会在当前创建一个新的事务(当前必有事务)

SUPPORTs:支持外层事务，如果没有的话，当前以非事务的方式运行（当前可能有事务，也可能无事务）

MANDATORY:支持外部事务，如果没有的话，直接抛出异常（当前必有事务）

Require_NEW:不支持外层事务，挂起外层事务，创建一个新的事务运行(当前必有事务)

NOT_SUPPORTED:不支持外层事务,挂起外层事务,当前方法以非事务的方式运行（当前无事务）

NEVER：不支持外层事务,直接抛出异常（当前无事务）

NESTED：支持外层事务，当前事务之前设置保存点.如果没有的话，则创建一个新的事务（当前必有事务）



####1.外层事务是Required

#####1.当前事务是Required，当前事务会延用外层事务。没有的话就新建一个事务

如果当前事务成功的话，外层事务失败的话，内层事务不会提交，外层事务统一回滚。

如果当前事务出错的话，外层事务成功的话, 内层事务不会提交，外层事务统一回滚。

如果当前事务成功的话，外层事务成功的话，内层事务不会提交，外层事务统一回滚。

如果当前事务失败的话，外层事务失败的话，内层事务不会回滚，外层事务统一回滚。

```java 
//如果之前已经存在事务，暂时不在此处回滚.
else {
    // Participating in larger transaction
    if (status.hasTransaction()) {
        if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {
            if (status.isDebug()) {
                logger.debug("Participating transaction failed - marking existing transaction as rollback-only");
            }
            doSetRollbackOnly(status);
        }
        else {
            if (status.isDebug()) {
                logger.debug("Participating transaction failed - letting transaction originator decide on rollback");
            }
        }
    }
    else {
        logger.debug("Should roll back transaction but cannot - no transaction available");
    }
    // Unexpected rollback only matters here if we're asked to fail early
    if (!isFailEarlyOnGlobalRollbackOnly()) {
        unexpectedRollback = false;
    }
}
```





##### 2.内层事务是RequiredNew，挂起外部事务，内层会单独开启自己的事务。没有的话，直接开启一个新事务

如果当前事务成功的话，外层事务失败的话，当前事务直接提交。外部事务回滚。

如果当前事务出错的话，外层事务成功的话, 当前事务先回滚，外层事务再回滚

如果当前事务成功的话，外层事务成功的话，当前事务先提交。外部事务后提交。

如果当前事务失败的话，外层事务失败的话，当前事务先回滚。外部事务后回滚。

```java 
//内层事务为RequireNew的情况
		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {
			if (debugEnabled) {
				logger.debug("Suspending current transaction, creating new transaction with name [" +
						definition.getName() + "]");
			}
			SuspendedResourcesHolder suspendedResources = suspend(transaction);
			try {
				return startTransaction(definition, transaction, debugEnabled, suspendedResources);
			}
			catch (RuntimeException | Error beginEx) {
				resumeAfterBeginException(transaction, suspendedResources, beginEx);
				throw beginEx;
			}
		}
//==========================================================================

```



##### 3.内层事务是SUPPORT，内层延用外部事务，没有的话，直接以非事务的方式运行。

如果当前事务成功的话，外层事务失败的话，内层事务不会提交，外层事务统一回滚。

如果当前事务出错的话，外层事务成功的话, 内层事务不会提交，外层事务统一回滚。

如果当前事务成功的话，外层事务成功的话，内层事务不会提交，外层事务统一回滚。

如果当前事务失败的话，外层事务失败的话，内层事务不会回滚，外层事务统一回滚。



##### 4.内层事务是NOTSUPPORT，当前方法以非事务的方式运行，有外部事务的话,挂起外部事务。

如果当前方法成功的话，外层事务也成功的话，外层事务提交。

如果当前方法失败的话，外层事务直接回滚提交。

如果外层方法失败的话，内层方法正常的话，内层方法不会回滚。外层事务会回滚。



```java 
  //内层事务为NOTSUPPORT的情况
		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {
			if (debugEnabled) {
				logger.debug("Suspending current transaction");
			}
			Object suspendedResources = suspend(transaction);
			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
			return prepareTransactionStatus(
					definition, null, false, newSynchronization, debugEnabled, suspendedResources);
		}
```





##### 5.当前事务是MANDATORY，当前延用外部事务，外层没有的话，直接抛出异常。

如果当前事务成功的话，外层事务失败的话，内层事务不会提交，外层事务统一回滚。

如果当前事务出错的话，外层事务成功的话, 内层事务不会提交，外层事务统一回滚。

如果当前事务成功的话，外层事务成功的话，内层事务不会提交，外层事务统一回滚。

如果当前事务失败的话，外层事务失败的话，内层事务不会回滚，外层事务统一回滚。



#####6.当前事务是NEVER，外层不能有事务，否则当前直接抛出异常，没有的话，直接以非事务的方式运行。

```java 
	if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {
			throw new IllegalTransactionStateException(
					"Existing transaction found for transaction marked with propagation 'never'");
		}
```





##### 7.当前事务时NESTED，直接延用外层事务，没有的话，直接创建一个新的事务运行

**savepoint的使用** savepoint  x;  rollback to x;  x之前的不会被回滚，x之后的会被回滚.

**和Required的区别**：

如果当前事务延用了外部事务的话，在开始当前事务之前，会设置一个保存点，savePoint.

在内层事务出错时，直接回滚到保存点.之后外层事务再回滚。

在内层事务成功时，释放保存点，之后外层事务统一提交

```java 
//如果之前设置了保存点的话，那么会回滚到保存点.
if (status.hasSavepoint()) {
    if (status.isDebug()) {
        logger.debug("Rolling back transaction to savepoint");
    }
    status.rollbackToHeldSavepoint();
}
//======================================================================
//如果当前事务设置了保存点的话，释放保存点。
if (status.hasSavepoint()) {
    if (status.isDebug()) {
        logger.debug("Releasing transaction savepoint");
    }
    unexpectedRollback = status.isGlobalRollbackOnly();
    status.releaseHeldSavepoint();
}
//如果当前事务是新事务的话，直接提交
else if (status.isNewTransaction()) {
    if (status.isDebug()) {
        logger.debug("Initiating transaction commit");
    }
    unexpectedRollback = status.isGlobalRollbackOnly();
    doCommit(status);
}
//如果当前事务，不是新事务的话
else if (isFailEarlyOnGlobalRollbackOnly()) {
    unexpectedRollback = status.isGlobalRollbackOnly();
}

```



如果当前事务成功的话，外层事务失败的话，内层事务不会提交但会释放保存点，外层事务统一回滚。

如果当前事务出错的话，外层事务成功的话, 内层事务不会提交,内层事务回滚到savePoint.外层事务后续回滚。

如果当前事务成功的话，外层事务成功的话，内层事务不会提交但会释放保存点，外层事务统一提交。

如果当前事务失败的话，外层事务失败的话，内层事务回滚到savePoint，外层事务再回滚。







### 2.外层事务是MANDATORY（外层必须有事务）

外层必须有事务，否则抛出异常.



### 3.外层事务是SUPPORTS（外层可以能有事务，也可能无事务）

#####1.如果外层有事务的话，当前事务是Required，当前事务会延用外层事务。

同上1



#####2.如果外层有事务的话，当前事务是RequiredNew，当前事务另开新事务

同上2





#####3.如果外层有事务的话，当前事务是SUPPORT，当前事务延用外层事务

同上1.





#####4.如果外层有事务的话，当前事务是NOTSUPPORT，当前事务不会使用事务

同上4



##### 5.如果外层有事务的话，当前事务是MANDATORY，当前事务延用外层事务

同上1



##### 6.如果外层有事务的话，当前事务是NEVER，当前事务延用外层事务

同上6

#####7.如果外层有事务的话，当前事务是NESTED，当前事务延用外层事务



同上1





**总结1：required ,nested的区别：**在于回滚

如果外部无事务的话，无区别。

1. 如果外部有事务的话，当内层事务出现异常时，二者抛出的异常信息不同。

2. 如果外部有事务的话，当内层事务出现异常，外层对内层进行手动捕捉时，required虽然捕获了异常，但是依然存在回滚标记。所以外层事务整体回滚。外层事务独有的也会回滚。

	但是nested的话内层在回滚到保存点的过程会清除回滚标记。所以外层因为手动捕获内层的原因，而导致了外层事务单独的提交。

```java 
public void rollbackToSavepoint(Object savepoint) throws TransactionException {
		ConnectionHolder conHolder = getConnectionHolderForSavepoint();
		try {
			conHolder.getConnection().rollback((Savepoint) savepoint);
			//清除回滚标记
			conHolder.resetRollbackOnly();
		}
		catch (Throwable ex) {
			throw new TransactionSystemException("Could not roll back to JDBC savepoint", ex);
		}
	}
```



**总结1：requiredNew ,nested的区别：**在于控制内层事务

如果外部无事务的话，无区别。

1. 如果外部有事务的话，requiredNew相当于单独另开了事务，外层事务不会影响到内层事务。内外层单独提交，单独回滚。

	但是nested的话，还是延用了外层事务。外层事务可以控制内层事务的回滚，就算内层事务没有异常，外层有异常的话，也可以全部回滚。













1,spring IOC
xml配置,注解配置
BeanFactory
BeanDefinition

2,spring上下文生命周期
refresh
start
stop
close

2.1 refresh 准备spring上下文阶段 
2.1.1 prepareRefresh()
2.1.2 obtainFreshBeanFactory()
2.1.3 prepareBeanFactory(beanFactory)
2.1.4 postProcessBeanFactory(beanFactory);
2.1.5 invokeBeanFactoryPostProcessors(beanFactory)
2.1.6 registerBeanPostProcessors(beanFactory)
2.1.7 initMessageSource()
2.1.8 onRefresh()
2.1.9 registerListeners()
2.1.10 finishBeanFactoryInitialization(beanFactory)
2.1.11 finishRefresh()



2.2 start

2.3 stop

2.4 close


3,springBean 生命周期

3.1 Bean元信息处理阶段
3.1.1 Bean元信息解析阶段:xml文件 注解 通过相应的BeanDefinitionReader转化成BeanDefinition
3.1.2 Bean注册阶段:将BeanDefinition保存至BeanDefinitionRegistry(典型实现DefaultListableBeanFactory)方便后续调用
3.1.3 BeanDefintion的合并阶段: (具有父类的属性)


3.2 Bean实例化阶段
3.2.1 Bean的Class加载阶段:resolveClass方法会将RootBeanDefinition里面记录的Bean信息加载成Class类保存至RootBeanDefintion里面
3.2.2 Bean的实例化阶段:利用构造器创建Bean
3.2.3 Bean的实例化前阶段:spring提供的Bean拓展方式
3.2.4 Bean的实例化后阶段:spring提供的Bean拓展方式 
3.2.5 Bean的赋值前阶段:?
3.2.6 Bean的赋值阶段



3.3 Bean初始化阶段:
3.3.1 Bean的aware接口回调阶段
3.3.2 Bean的初始化前阶段
3.3.3 Bean的初始化阶段
3.3.4 Bean的初始化后阶段



3.4 Bean销毁阶段
3.4.1 Bean的销毁前阶段
3.4.2 Bean的销毁阶段


3.5 Bean垃圾收集阶段
spring会在上下文关闭后触发GC 触发spring Bean的垃圾收集

4 spring的三级缓存
4.1 singletonObjects  一级
4.2 earlySingletonObjects 二级
4.3 singletonFactories 三级

一级缓存想要进入二级缓存的话，必须满足两个条件 1，一级缓存没有 2，对象正处于创建状态

实例化A------>一到三级缓存检索A,未发现A开始创建A------------>将A转化成ObjectFactory并且放入singleFactories中去
初始化A过程中,发现RunBeanReference B，一到三级缓存中检索B,未发现B，开始创建B
实例化B------------>将B转化成ObjectFactory并且放入singleFactories中去
初始化B过程中,发现RunBeanReference A,一到三级缓存中检索A，发现singleObjectFactory中的beanName,执行ObjectFactory.getObject()方法即getEarlyReference(),如果是代理对象,完成代理对象的创建,由三级缓存singletonFactories移动至二级缓存earlySingletonObjects
初始化B完成,此时B中的属性A已被填充。如果
将初始化后的B由三级缓存移动至一级缓存。
初始化A完成,此时A中的属性B已被填充.
将初始化后的A由二级缓存移动至一级缓存。



5,




