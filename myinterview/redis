#### 1.什么是Redis

redis是内存数据库，每秒能完成10万次读写，可以用作缓存，数据库。

#### 2.Redis有哪些优缺点

优点：

1. 数据放在内存，读写速度非常快。减轻了数据库压力

2. 单线程处理请求，所有操作都是原子性的,可以用作分布式锁

	===============================================

3. 数据持久化RDB,AOF

4. 数据结构丰富

5. 支持主从复制

缺点：

==================================================================

1. 物理内存有限，不适合海量数据的存储

2. 主机宕机前，部分数据未同步到从机上，重新选举master成功时，会造成数据不一致

3. Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求 失败，需要等待机器重启或者手动切换前端的IP才能恢复

4. Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避 免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的 浪费  

	



#### 3.为什么使用Redis做缓存？

1. 高性能：数据放在内存，读写速度非常快。
2. 高并发：减轻数据库压力,直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑 把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这 里而不用经过数据库。
3. 

####4. 为什么要用 Redis 而不用 map/guava 做缓存?

Java map本地缓存 存放在虚拟机,多个JVM进程，多份缓存，缓存不一致

redis 多个JVM可以共用一份缓存，缓存一致性。需要redis维持高可用。



#### 5.Redis为什么这么快？

1.  redis数据直接加载到内存，从内存读取，写入数据非常快。

2.  redis采用epoll模型与客户端交互。非阻塞IO，多路复用，并且与内核共享一份内存。节省了用户态与内核态复制交换数据的过程。

	============================

3. 单线程处理客户端请求，不用线程上下文切换带来的成本。不用考虑多线程同步，锁造成的效率低下，以及死锁问题。

4. 数据结构简单，操作数据结构简单

	

	

	

#### 6.Redis有哪些数据类型

1. string  key value
2. hash  key ------------>多个key value
3. list
4. set
5. zset （sortedSet）



#### 7.Redis应用场景

1. 计数器 高性能自增，自减计算

2. 缓存 将热点数据存放至内存。设置内存最大使用量，以及key的淘汰策略来保证热点数据。  

	=======================================================

3.  **可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存 储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务 器，从而更容易实现高可用性以及可伸缩性。 

4. 全页缓存（FPC） 除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例， Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以 快速度加载你曾浏览过的页面。 

	1. 例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了  Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效， 因为缓存不作为可靠的数据来源。 

5. list双向链表，用作消息队列 lpush lpop （最好使用MQ用作消息队列）

6. 单线程，SETNX用作分布式锁

7. set交集，并集 用作计算共同好友。  zset有序，用作排行榜





#### 8.Redis数据结构的应用

1. string  key-value 存储短信验证码,配置信息
2. hash value对应商品详情，个人信息详情,新闻详情
3. list FIFO队列 存储一些相对固定的数据。省市表
4. set 唯一性 可以进行交集，并集操作。好友列表。选出共同好友。
5. zset set的升级版，有序set  设置score 用作排行榜





#### 9.Redis 的持久化机制是什么？各自的优缺点？

1.AOF RDB 



rdb的优点：

1. 二进制文件，用RDB恢复，直接使用二进制，效率非常高.

	-================================================

	1. 只有一个文件 dump.rdb，方便持久化。 
	2. 容灾性好，一个文件可以保存到安全的磁盘。 
	3. fork子进程异步对数据进行备份。使用了写时复制技术。不影响客户端正常的请求。效率非常高。保证了Redis的高性能。



rdb的缺点：

1. 时效性低，丢失数据较多，按时间点备份数据。在时间之后的数据容易丢失。



redis4.0之前 aof的优点:

1. 时效性高，丢失数据较少。可以每次发生redis请求时 备份 或者每秒备份。

	=============================================================

	1. 通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-checkaof 工具解决数据一致性问题。 
	2. AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命 令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）) 



redis4.0之前 aof的缺点

1.  aof文件多为redis命令。恢复时，需要程序进行翻译，在执行。效率低下

	===================

2. aof文件大，导致REDIS启动时，速度变慢。





#### 10.Redis key的过期时间和永久有效分别怎么设置？

expire  persist



#### 11.我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?

1.主动删除

对于已经过期的数据，主动删除

没10秒定时执行一次，在过期间集合中，随机取出20个设置了过期键的集合，删除已经过期的键。再统计，如果过期键的集合占用设置了过期间总数据的比例仍然大于25%，重复之前的一步。直到过期键的集合占用总数据的比例仍然小于30%，停止。

2.被动删除

对于已经过期的数据，如果请求再次访问到，那么redis会删除过期的数据.





#### 12.Redis的内存淘汰策略有哪些

1. 服务端返回错误。不能正常请求，不驱除任何键
2. 从设置了过期时间的键集合中回收所有过期了的键
3. 根据LRU算法，从所有键中淘汰最长时间没有使用 的键
4. 根据LRU算法，从所有设置过期键集合中淘汰没有使用的键
5. 送所有键中随机删除。
6. 从设置键中随机删除。
7. 根据LFU算法，从所有键中淘汰最少使用次数 的键

8. 根据LFU算法，从所有设置过期键集合中淘汰最少使用次数的键



1. 最长时间没有使用  LRU算法原理

	1. redis键内部24bit位维护一个时钟，并且有一个全局时钟。最长194天，过了194天重新开始计时。

	2. 每次键发生访问时，将全局时钟更新到key内部时钟。

	3. 淘汰时，将key内部时间与全局时钟做比较。全局时钟大于内部时间取差值，小于内部时间的取和。差值越大的最长时间没有使用。

	

2. 最少使用次数   LFU算法原理

1.  LRU算法的问题：经常使用的key可能被LRU删除。如果只有最进一次使用间隔较长，之前一直很频繁，那么很可能被LRU删除。 

2.  key内部16位当时钟 时分秒  剩余8位当使用次数。访问时间间隔越长，次数越小。间隔越小，次数越多。

3. 可以设置衰退因子。当为1时，1分钟没访问，次数减1.
4. 新生key次数为5.防止过快被淘汰.





#### 13.什么是事务？

1. 事务内部的操作不会被外部操作影响，打断
2. 事务内部的操作有序执行。

3. 事务具有原子性，事务里面的命令要么全部成功，要么全部失败。



#### 14.Redis事务的相关概念

multi 开启一个事务

命令入队

exec 按顺序执行队列中的所有命令

**redis事务不支持回滚**

**watch命令监视multi 之后入队所有命令，一旦命令中相关的键被删除，或者修改的话，那么此次multi失效**

**discard 从Multi状态中退出**

**redis的事务不具有原子性，事务当中一条命令失败，其他正确的命令仍然可以被执行**



#### 15.Redis的集群模式

redis集群模式启动的话，redis把16384个hashSlot 分散在每个节点上，存入的数据经过hash一致性算法，存储在对应节点的hash slot上。请求数据的话，如果当前key不在本节点上，那么就会hash计算请求所在数据的节点。

可以增加，删除集群中的节点，可以resharding重新分配hash槽。

节点的通信使用gossilb协议。



##### 16.Redis分区的缺点

1. 不同分区的key不能取交集操作
2. 同时操作多个key，不支持事务
3. 分区的动态扩容困难

#### 17.Redis set if not exits key 设置 用作分布式锁

如果存在，别的线程都会设置失败。返回0.  

为了防止莫一个线程因为其他原因没有释放锁，可以给key设置过期时间，来设置锁的过期时间。



#### 18.什么是缓存穿透？

缓存穿透指 数据库 缓存都不存在 大量的无效请求压力 移交至数据库



#### 19.缓存穿透的解决方案

1. 接口层，请求参数校验
2. 对于数据库查询不出数据的key redis设置未null ,停止对数据库访问
3. Redis布隆过滤器,过滤请求key



#### 20.Redis布隆过滤器原理

1. 底层维护一个bitmap数组，每一个都是二进制位

2. 对于任意一个过滤的key生成一定数量的HashFunction,如果计算出来的hash值命中bitmap的索引，那么将此索引处的bit位设为1.

3. 对于请求的key 也生成一定数量的HashFunction,如果计算出来的HashFunction的hash值命中的索引的bit位为0的话，那么此key一定不存在。

	如果计算出来的HahsFunction的hash值命中的索引的bit都为1的话，那么此key也可能不存在，但是机率非常小。此时可以通过查询数据库，及时更新缓存，标记此元素不存在。



  ####21.什么是缓存击穿？

缓存中没有，但是数据库存在的数据(**一般是指缓存数据过期了，或者被内存淘汰机制给淘汰了**)。某一时间请求这条数据的并发数特别大，导致数据库压力瞬间增大。与缓存雪崩不同的是，缓存雪崩指的是对不同数据的高并发访问。不去查数据库，而是去查数据库。



#### 22.缓存击穿的解决方案

1. 设置热点数据永不过期
2. 设置分布式锁，如果访问缓不存在的话，获取锁，允许一个实例 查询数据库，将数据更新到缓存。这样因为锁的原因，一次也只有一个请求访问数据库。
3. 设置定时更新缓存，同步数据库数据。



#### 23.什么是缓存雪崩？

缓存中没有，但是数据库存在的数据。某个时间段，比如0：00大量key失效，高并发请求访问不同数据，把压力全部抛给数据库了



#### 24.缓存雪崩的解决方案

1. 热点数据永不过期
2. 设置分布式锁，如果访问缓不存在的话，获取锁，允许一个实例 查询数据库，将数据更新到缓存。这样因为锁的原因，一次也只有一个请求访问数据库。
3. 不是特定时刻需要过期的key，设置key的过期时间为随机，避免key在同一时间大量失效。











#### 24.统计某个用户一年登录的实际天数

为每个用户设置一个365位的bitmap ，如果某天登录了，就在某天的bit位置为1 统计一年用bcount key [start]  [end] 的值，即为登录的实际天数



#### 25.如何统计一年所有的活跃用户数。登录过一次就算活跃用户，相同用户登录多次只算一个活跃用户。

为每一天设置一个所有用户数量的bitmap.如果某天第N个用户登录了，就在该天的bitmap的第N位置为1。

把一年所有天数的bitmap做或运算。得出最终的bitmap，使用bcount 统计这个bitmap计算出来的值，即为这一年所有的活跃用户数。