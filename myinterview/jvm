##### 1.说一下 JVM 的主要组成部分及其作用？

（只是运行时数据区域）

1. 堆内存  JVM存储对象的区域
2. 栈内存  方法运行时，开辟的内存区域。
3. 堆外内存 直接使用系统管理的内存
4. 方法区 存放类CLass文件信息，
5. native 区  本地native方法 运行的内存区域

=========================================

1. ClassLoader 类加载系统：加载本地Class文件到运行时数据区域的方法区内
2. 执行引擎  调用本地native接口 把Class文件翻译成机器指令交给CPU执行
3. 运行时数据区域 存放Class文件信息内存区域
4. 本地native接口 将Class文件编译成机器指令



##### 2.说一下 JVM 运行时数据区

1. 堆内存  JVM存储运行时产生对象的区域
2. 栈内存  方法运行时，开辟的内存区域。
	1. 操作数栈 : 压入变量，弹出变量
	2. 本地变量表 ：存储方法定义的变量的值
3. 堆外内存 直接使用系统管理的内存
4. 方法区 存放类CLass文件信息，类的静态变量，常量都存贮在此区域
5. native栈 区  本地native方法 运行的内存区域
6. 程序计数器  定位执行字节码指令的位置，控制字节码指令的执行流程



##### 3.深拷贝和浅拷贝

1. 浅拷贝

	1.直接把对象的引用地址 传给另一个对象。

	2.实际并没有赋值一个新对象，对此对象值的改变，会影响到原对象

2. 深拷贝

	1. 直接开辟一个新的内存区域，新对象的属性值，方法与原对象一样，

		对新对象的改变不会影响到原对象.



#####4.说一下堆栈的区别？

1. 堆:JVM堆内存，对象的存储区域
2. 栈:方法运行时，开辟的内存区域

==============================

内存区别：

 堆内存不连续，只能运行时确定。大小远大于栈

  栈内存连续，只能编译期间指定。



存储的数据不同：

堆内存存储 运行时的对象，jdk1.8之后是方法区也放在栈

栈内存存储局部变量，操作数栈



可见度不同：

堆被所有线程所共享

栈每个线程都有自己独立的栈空间，他的生命周期和线程一致。线程执行完，销毁线程栈。



##### 5.队列和栈是什么？有什么区别

队列：先进先出的数据结构  队首入队 队尾出队

栈：先进后出的数据结构 只能压栈 只能对栈顶进行操作



#####6. 说到对象的创建，首先让我们看看 Java 中提供的几种对象创建方式：

1.new ()

2.constructor.new Instance()

3.object.clone

====================================

4.class.new Instance()

注意 constuctor.new Instance() 就可以无参，也可以有参，设置权限 可以调用私有

​         class.new Instance()  只可以默认无参 ，不能调用私有



##### 7.创建对象的分配内存空间时，可能存在并发冲突问题

解决方案：1.CAS 更新分配  

​                   2.JVM 预先分配一块线程的专属内存区域。哪个线程要使用内存，就在哪个线程专属的JVM堆上获取。不够时，同步上锁再分配。





##### 8.内存溢出异常 java会出现内存泄漏吗？

内存泄漏，指的是没用的数据 占用了内存，得不到清理。

JVM有GC机制，可以回收垃圾对象。防止内存泄漏。但仍然存在内存泄漏问题。





##### 9.如何判断对象是否可以被回收？

1. 可用计数法:引用依次 加1.引用断掉 减1.如果GC回收时发现数量为0，回收此对象。

	A《-----------》B    A,B循环依赖  A被回收   B无法被回收

	**问题：没法回收引用的引用**

2. 根可达算法:如果一个对象没有被其他对象引用。包括间接引用。

	GCROOT-----------》B------------》C    沿着ROOT一直往上找，如果ROOT没有堆此对象引用，回收此对象。



##### 10.JVM的垃圾回收算法

1.标记清除算法 标记无用对象区域，直接清除   优点：效率高。  缺点：内存利用率不高。造成内存碎片。

2.标记复制算法 把内存划分为有用区域，无用区域。标记无用对象区域，复制到有用的的区域，清除垃圾对象区域的所有对象

优点：内存利用率高，不会造成内存碎片。 缺点：效率低。

可以用于新生代生存率较低的对象很多。

3.标记整理算法  标记无用对象区域  将有用对象 使用压缩算法移动到存活对象的一边，清除垃圾区域的对象。

老年代，生存率高的对象较多。不适宜复制算法，清除会产生内存碎片。所以采用标记整理算法。



#####11.JVM的垃圾回收器(垃圾回收算法的具体实现)

1.Serial 单线程回收垃圾  回收时出现STW事件

   对新生代使用复制算法 

 SerialOld  对老生代使用标记整理 或者标记清除。

​              





2.Parnel  多线程回收垃圾  回收时出现STW事件 

a,ParnellOld   针对老年代

b,ParnelNew  针对新生代 



c,ParnelScavenge 针对新生代。减少垃圾回收时间。





3.ConcrrentMarkSweep  用户线程与垃圾回收线程并发执行 (不一定并行执行，可能交替执行) 针对老年代。

1.采用标记清除算法

过程：

1.初始标记 STW  多线程标记Root对象

2.并发标记  不发生STW 回收垃圾线程与工作线程并发执行。回收垃圾线程标记存活对象以及垃圾对象。

3.重新标记 发生STW 多线程清除未存活对象。

4.并发清除 多线程回收所有标记的垃圾对象。



G1



















