##### 1.说一下 JVM 的主要组成部分及其作用？

（只是运行时数据区域）

1. 堆内存  JVM存储对象的区域
2. 栈内存  方法运行时，开辟的内存区域。
3. 堆外内存 直接使用系统管理的内存
4. 方法区 存放类CLass文件信息，
5. native 区  本地native方法 运行的内存区域

=========================================

1. ClassLoader 类加载系统：加载本地Class文件到运行时数据区域的方法区内
2. 执行引擎  调用本地native接口 把Class文件翻译成机器指令交给CPU执行
3. 运行时数据区域 存放Class文件信息内存区域
4. 本地native接口 将Class文件编译成机器指令



##### 2.说一下 JVM 运行时数据区

1. 堆内存  JVM存储运行时产生对象的区域
2. 栈内存  方法运行时，开辟的内存区域。
	1. 操作数栈 : 压入变量，弹出变量
	2. 本地变量表 ：存储方法定义的变量的值
3. 堆外内存 直接使用系统管理的内存
4. 方法区 存放类CLass文件信息，类的静态变量，常量都存贮在此区域
5. native栈 区  本地native方法 运行的内存区域
6. 程序计数器  定位执行字节码指令的位置，控制字节码指令的执行流程



##### 3.深拷贝和浅拷贝

1. 浅拷贝

	1.直接把对象的引用地址 传给另一个对象。

	2.实际并没有赋值一个新对象，对此对象值的改变，会影响到原对象

2. 深拷贝

	1. 直接开辟一个新的内存区域，新对象的属性值，方法与原对象一样，

		对新对象的改变不会影响到原对象.



#####4.说一下堆栈的区别？

1. 堆:JVM堆内存，对象的存储区域
2. 栈:方法运行时，开辟的内存区域

==============================

内存区别：

 堆内存不连续，只能运行时确定。大小远大于栈

  栈内存连续，只能编译期间指定。



存储的数据不同：

堆内存存储 运行时的对象，jdk1.8之后是方法区也放在栈

栈内存存储局部变量，操作数栈



可见度不同：

堆被所有线程所共享

栈每个线程都有自己独立的栈空间，他的生命周期和线程一致。线程执行完，销毁线程栈。



##### 5.队列和栈是什么？有什么区别

队列：先进先出的数据结构  队首入队 队尾出队

栈：先进后出的数据结构 只能压栈 只能对栈顶进行操作



#####6. 说到对象的创建，首先让我们看看 Java 中提供的几种对象创建方式：

1.new ()

2.constructor.new Instance()

3.object.clone

====================================

4.class.new Instance()

注意 constuctor.new Instance() 就可以无参，也可以有参，设置权限 可以调用私有

​         class.new Instance()  只可以默认无参 ，不能调用私有



##### 7.创建对象的分配内存空间时，可能存在并发冲突问题

解决方案：1.CAS 更新分配  

​                   2.JVM 预先分配一块线程的专属内存区域。哪个线程要使用内存，就在哪个线程专属的JVM堆上获取。不够时，同步上锁再分配。





##### 8.内存溢出异常 java会出现内存泄漏吗？

内存泄漏，指的是没用的数据 占用了内存，得不到清理。

JVM有GC机制，可以回收垃圾对象。防止内存泄漏。但仍然存在内存泄漏问题。





##### 9.如何判断对象是否可以被回收？

1. 可用计数法:引用依次 加1.引用断掉 减1.如果GC回收时发现数量为0，回收此对象。

	A《-----------》B    A,B循环依赖  A被回收   B无法被回收

	**问题：没法回收引用的引用**

2. 根可达算法:如果一个对象没有被其他对象引用。包括间接引用。

	GCROOT-----------》B------------》C    沿着ROOT一直往上找，如果ROOT没有堆此对象引用，回收此对象。



##### 10.JVM的垃圾回收算法

1.标记清除算法 标记无用对象区域，直接清除   优点：效率高。  缺点：内存利用率不高。造成内存碎片。

2.标记复制算法 把内存划分为有用区域，无用区域。标记无用对象区域，复制到有用的的区域，清除垃圾对象区域的所有对象

优点：内存利用率高，不会造成内存碎片。 缺点：效率低。

可以用于新生代生存率较低的对象很多。

3.标记整理算法  标记无用对象区域  将有用对象 使用压缩算法移动到存活对象的一边，清除垃圾区域的对象。

老年代，生存率高的对象较多。不适宜复制算法，清除会产生内存碎片。所以采用标记整理算法。



#####11.JVM的垃圾回收器(垃圾回收算法的具体实现)

1.Serial 单线程回收垃圾  回收时出现STW事件

   对新生代使用复制算法 

 SerialOld  对老生代使用标记整理 或者标记清除。

​              





2.Parnel  多线程回收垃圾  回收时出现STW事件 

a,ParnellOld   针对老年代

b,ParnelScavenge 针对新生代。减少垃圾回收时间。





3.ConcrrentMarkSweep  用户线程与垃圾回收线程并发执行 (不一定并行执行，可能交替执行) 针对老年代。

ParnelNew  针对新生代 可于CMS配合

1.采用标记清除算法

过程：

1.初始标记 STW  多线程标记Root对象

2.并发标记  不发生STW 回收垃圾线程与工作线程并发执行。回收垃圾线程标记存活对象以及垃圾对象。

3.重新标记 发生STW 多线程标记之前没做完的标记过程。

4.并发清除 多线程回收所有标记的垃圾对象。



G1 用户线程与垃圾回收线程并发执行

1.物理不分代，逻辑分代

2.短暂存活的大对象放入H区域

3.整个堆划分为一个个固定大小的region,region的角色可划分为 Y  S  O  H



新生代回收过程：YGC

新产生的对象直接放入region ，标记region 为Y。 之后Y区域不够了的话，存活对象放入空白区域，设置为S。



老年代回收过程  叫MIXEDGC

触发条件：当老年代的堆占有率超过指定参数时

**<font color='yellow'>有一个期望垃圾回收时间，如果GC判断回收n个region区域的时间超过设置的值，那么超过n的region就会等待下次GC回收,回收的算法是复制。</font>**

1.初始标记 STW  与CMS相同

2.并发标记 不发生STW 与CMS相同

3.重新标记 ，发生STW 多线程标记之前没做完的标记过程。

4.清除回收 STW 清除垃圾区域



FGC

如果MIXGC期间复制存活对象的空白的region区域不够了的话，那么退化为serialNo.





##### 12.常用的JVM参数

-Xms 最小堆

-Xmx 最大堆

-XX:+UseConcurrentMarkSweep 用CMS垃圾回收

-XX:+NewRatio=4 设置 年轻 老年代的比例

-XX:+PrintGC 开启打印GC信息









