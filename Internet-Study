##1.OSI 七层网络模型

#### 1.物理层

计算机二进制数据的传输方式 比如光缆，比如：电缆，无线电波

物理设备：网卡,网线。

#### 2.数据链路层

多少个二进制信号算作一个数据，每个信号有什么意义。 比如：以太网协议

规定一组电信号构成一个数据包，又称作一帧。每一帧分为head  data

网卡与网卡传输数据，每个网卡都有自己世界上唯一的MAC地址编号。

1. 同一网段，发送数据时，网卡会将接收者MAC地址，发送者MAC地址封装在head里。采取广播的方式。向本网段的所有计算机发送，其他计算机根据接收的MAC地址，判断自己是否接收数据。

2. 不同网段，发送数据时，网卡根据路由将数据发送到其他网段。

物理设备：交换机. 根据MAC地址，使不同计算机可以交换数据.

#### 3.网络层

对于不同网段需要IP协议 分为IP4协议，IP6协议

也分为head data **ip数据包的内容直接放入以太网数据包中的data部分的**

1. ip4协议 ip地址 4bit.4bit.4bit.4bit  子网掩码4bit.4bit.4bit.4bit

2. ip地址和子网掩码做二进制&运算 返回网段，

3. 不同网段，交由网关做路由处理，发送不同网段
4. 相同网段，经由ARP协议询问同一网段内的MAC地址

物理设备：路由器  路由器根据发送的IP地址，内网的话，根据交换机MAC传输。外网的话，经由网关，发送广域网.

#### 4.传输层

网络端口之间的协议，TCP，UDP协议

TCP分为3此握手，4次分手。

也分为head data **TCP/UPD数据包的内容直接放入ip数据包中的data部分的**

应用程序之间通信



计算机防火墙.0-1023被系统占用.



####5.会话层

####6.表示层

#### 7.应用层

应用程序，为了方便解析数据。http 协议

也分为head data **http数据包的内容直接放入TCP数据包中的data部分的**



应用程序之间规定数据的格式，对其进行编码，解码.



## 3.IP协议





##4.TCP协议





####1.TCP连接 长连接，短连接，长轮询，短轮询

1. 短连接:客户端每次发送请求，服务端接收请求后，返回响应。Socket关闭
2. 长连接：客户端每次发送请求，服务端接收请求后，返回响应。Socket保持活动
3. 短轮询：客户端请求服务端，服务端有没有数据，立即给与客户端有无的响应。如果无，客户端不断请求服务端，直至获取数据响应.
4. 长轮询：客户端请求服务端，服务端不管有没有数据，如果没有数据，请求被挂起。处理另一个请求，等待请请求时，在发送响应给客户端

**轮询建立在连接基础上，轮询是长是短与连接是长是短无关。 **





####2.建立连接的3次握手

1.A发送数据给B 

若B返回ACK 此时说明B具有接收数据的能力，A也具有发送数据的能力，否则失败

数据到达B，B知道了自己具有接收数据的能力。



2.B发送ACK给A

A知道了自己不但有发送数据的能力，而且还有接收数据的能力，并且知道了B也具有接收数据的能力，和发送数据的能力。否则失败

**<font color='yellow'>此时B仍然不知道自己有发送数据的能力以及A是否具有接收数据的能力，因此A需要再次发送一个ACK给B</font>**



3.A发送ACK给B

B知道了自己具有接收数据的能力。





####3.断开连接的4次分手

1.A发送Fin给B





2.B立即发送ACK给A。

B已经知道A没有要发送的数据了，此时B并不会立即关闭连接。因为有的数据可能正在发送。等待一段时间过后CloseWait.

<font color='yellow'>这里就是多出来的一次发送</font>





3.B发送Fin 给A

A知道，B也已经没有要发送的数据了。





4.A立即发送ACK给B 

B知道A已经知道它准备关闭连接了。



B收到A的ACK之后立即关闭连接。

<font color='yellow'>但是A需要等待2MIN之后，TimeWait才会关闭连接</font>

<font color='yellow'>原因：因为此时B可能没有正常关闭连接。因此A需要等待2MIN来确认B。如果B真的没有关闭，那么B发送的数据，A再TIMEOUT期间仍然能够接收的到。</font>





#### 4.Tcp如何保证消息传输的可靠性的？

#####1.校验和。发送方对数据进行计算校验和。接收方也对数据继续计算校验和。比对结果。

##### 2.确认应答与序列号

为了应答。每次传输的数据有序。告诉发送方，接收了哪些数据。下次数据从哪发

##### 3.超时重传

到达指定时间，接收方没有收到消息。发送方进行消息重传。如果序列号重复，那么直接丢弃。



#####4.连接管理

3次握手4次分手

##### 5.流量控制

先发送较少的数据，探测对方缓冲区的大小。再根据返回的ack决定自己发送数据的大小。

##### 6.拥塞控制













# 5.HTTP协议

### 1.请求头 key: value

1. content-type
2. content-length
3. accept
4. reference
5. 

### 2.请求方法

1. get
2. post
3. put
4. delete
5. trace
6. patch

### 3.状态码

1. 1XX 提供信息  101 切换协议 服务端通知客端端之后该切换协议发送了

2. 2XX 成功

	200成功 OK

	201已创建 created

	203非权威内容 Non-Authoritative  Information

	204没有内容 No Content

	205重置了内容 Reset Content

	206服务端下发了部分内容 range header  [0~10]M  [10-20]M

	

3. 3XX 重定向

	300 用户请求了多个选项的资源 Mutiple-Choices

	301资源被永久转移 Moved Permanently

	302 资源被找到  FOUND

	303 可以使用GET方法在另一个URL找到资源

	304 没有修改 Not  Modified 主要用于说明缓存

	305需要代理  Use Proxy

	307临时重定向 Temporary Redirect

	308永久重定向 Permanently Redirect

	

	301,308

	共同点：都是说明资源被转移到新的URL

	不同点：客户端收到308请求后，延用旧的method(POST/PUT/GET)到新的URL

	​                客户端收到301请求后，只会用GET请求新的URL

	

	302、303、307

	共同点：资源临时放到新的URL

	不同点：客户端能收到302请求后，只会用GET请求临时新的URL

	​                303：服务端告诉客户端采用GET请求临时新的URL

	​                307：服务端告诉客户端采用原METHOD请求临时新的URL

	

4. 4XX 客户端错误 

	400请求格式错误  Bad Request

	401没有授权 Unauthorized

	402请先付费 PaymentRequired

	403禁止访问 Forbbiden

	404没有找到 NOT FOUND

	405方法不被允许 Method  Not Allowed

	406 服务端返回的内容和客户端期待accept里的内容不匹配

	

5. 5XX 服务端错误

	500  内部服务器错误 Interval Server Error

	501 服务端的接口没有实现 Not Implemented

	502 网关错误 （网关访问不了应用服务)   Bad GateWay

	503 服务不可用 （应用服务出错) Service Unavaiable

	504 网关超时 GateWay TimeOut

	505 HTTP协议版本 不支持  HTTP VERSION NOT SUPPOTED



### 4.http缓存

1. Least Recently used 缓存淘汰算法 最长时间没有使用
2. 通过服务端响应头 设置http缓存  Cache-Control:max-age:10000  时间单位s



#### 获取缓存流程

1. 缓存到期前，获取浏览器缓存（强制缓存）

#### 缓存类型

1. 基于时间确定的强制缓存

Cache-Control:public

Expires:Fri,16 Oct 2020 02:02:03 GMT

参过expire日期就会失效



2. 协商缓存：在资源发生变化前，都使用浏览器缓存。所以必须每次请求服务器。确定是否资源发生变化，如果变化，直接从服务器获取。

	实现形式 ETAG   ETAG不变，表示资源不变。

	

3. 基于时间的协商缓存

LastModified头 如果发生变化，发出变化时间，没有变化的话，返回304





### 5.Keep-Alive：多次请求复用一个TCP连接

Keep-Alive:timeout=5,max=1000

单个请求：请求完成后timeout 时间内没第二个请求进来，关闭

多个请求：在一个请求响应后，在timeout时间内由另一个请求进来，就会利用相同的TCP连接继续响应这个请求。直到没有更多的请求进来，可以通过max字段设定最多响应的请求数量。

















#6 什么是代理服务器？

代理服务器接收客户端请求，转发给服务端。在从服务端获取响应，转发给客户端.分为正向代理，反向代理。

### 1.正向代理

客户端把请求的网址，资源，**目标服务器的信息**发送给代理服务器，由代理服务器发送请求，获取目标服务器资源后，返回给客户端。



### 2.反向代理

客户端发送请求给代理服务器，客户端不知道真实的目标服务器。反向代理服务器获取真实服务器的响应后，把数据返回给客户端。









# 7.加解密

### 1.对称加密

加密解密用的同一个密钥，且加密方，揭密方都知道密钥。 DES,3DES

A发送消息给B，不想让消息以明文的方式展现，A通过密钥加密明文。B通过密钥解密密文。







### 2.非对称加密

加密方用一个密钥，解密用另一个密钥，且加密方一般有两个2个密钥。解密方只有一个解密密钥。 RSA算法





问题：A发送消息给B，用了密钥加密，但是如果A的密钥不小心泄漏给了其他人。其他人截获消息，用偷来的密匙解密。

改进：A通过自己的公钥加密，发送给B。但是此消息只能通过B的私钥来解密，才能显示明文。B的私钥不会轻易泄漏。



问题：A发送消息给B，有人冒充A，通过A的公钥加密，发送给B。B无法判断此消息到底是不是A发的

改进: A通过自己的私钥加密，B收到消息后，如果能通过A的公钥解密  ，那么证明是A的证明消息的来源。







### 3.摘要算法

 消息摘要可以将消息哈希成一个长度固定的唯一值。值唯一的意思是不同的消息转换的摘要是不同的，并且能够确保唯一。该过程不可逆，即不能通过摘要反推明文。常用的消息摘要算法有MD5、SHA1、SHA256、SHA512等。 





### 4.数字签名

对摘要内容进行加密就是数字签名。

问题：A发送消息给B，并且先用自己的公钥加密明文，再用自己的私钥加密来源。此时如果消息很大很大时。加密需要很长的时间，解密也需要很长的时间。那么效率低下。



改进：A用公钥对明文加密，再用摘要算法对消息进行计算，得到消息的固定长度，再用自己的私钥对摘要进行加密连同加密后的明文一起发送。

1. B收到消息后，用A的公钥对摘要进行解密，如果成功，说明消息来源正确。

2. 再用自己的私钥对密文进行解密得到明文。防止了别人阅读原文。

3. 再用摘要算法对明文进行计算，算出的Hash值如果和解密后的摘要的值一致，说明明文内容没有被修改。否则说明被改动。



### 5.数字证书



问题：A的公钥是公开的，任何人都可以获得，假如C取得了A的公钥，并且用其他手段将自己的密钥替换了B中A的公钥，之后C用自己的私钥加密摘要，发送给B，那么此时B再身份认证时，就会错误的把C当作A，因为B中有关A的公钥，被C偷偷用自己的公钥替代了。



改进：使用数字证书

```javascript
Issuer：CA
Subject：Dablelv Company
Valid from：某个日期
Valid to：某个日期
Public Key：一串很长的数字
{证书的指纹和计算指纹所使用的指纹算法}[CA的私钥|RSA]	//这个就是CA对这个证书的一个数字签名，表示这个证书确实是他颁发的，有什么问题他会负责
...证书其它内容...
```

1. 操作系统内置证明数字证书发布机构的证书。如果在其名单之内，则系统通过，否则系统抛出异常
2. CA等权威机构发布的证书绝对安全，保证证书不被别的第三方替换
3. A向CA申请证书。发送B时加入数字证书
4. B根据自己系统的受信任的证书发布机构的白名单，对A发送的证书进行校验，不通过，直接抛出异常。通过用数字证书的公钥和数字证书的指纹算法对证书的数字签名进行解密。解密成功得出摘要。再自己使用指纹算法对证书进行指纹计算得出实际的指纹。如果摘要和实际指纹一样，说明消息没有没修改。并且此证书是CA发布的说明消息确实来自A。



**如果有一千个在CA申请过证书的机构向B发送消息，B要保存一千份不同的证书吗？**

改进：不合理，所以CA中心会 给客户端一个根证书。根证书记载了所有在CA注册审批过的证书。分叉书存储的。

这些机构只需发一个公钥出来即可在根证书中查找是否是CA注册过的公钥。



# 8.Https

https效率与安全兼顾，对传输实际数据，进行非对称加密，对加密传输数据的密钥进行对称加密。

1. 客户端请求服务端。
2. 服务端收到客户端请求，发送自己注册的证书给客户端。证书上有服务端注册的公钥。
3. 证书绝对安全，一般正规机构发布的证书，系统信任，不可能被随意冒充，如果冒充，证书机构付法律责任。
4. 客户端拿到服务端的证书，与浏览器内置的根证书比较，如果存在，用公钥解密指纹，再用指纹算法计算解密后的指纹。如果指纹一致，说明证书内容没有被串改。
5. 得到指纹后，客户端用公钥加密生成一个密钥传输给服务端。此密钥只能用服务端的私钥解密。
6. 服务端用自己的私钥解密客户端传输过来的密钥，用解密后的密钥加密传输数据。此加密只有客户端生成的密钥才能解密。至此https完成一次完整的数据交互过程。



# 9.Http2.0

1. http 早期版本  一次http请求，一次TCP连接。 下一个请求，等待上一个TCP连接关闭后，才能新建立连接请求

2. 之后，一次http请求一次TCP连接。下一个请求，可以与上一个TCP连接并行建立。发出新的请求。

3. 再之后http1.0 1.1都有keepAlive  一个TCP连接，可以进行多次http请求。但是下一请求的发出，必须等待得到上一个请求响应的到达，否则会一直阻塞。队首阻塞问题。

	

4. http2.0 http报文编码，解码的方式发生变化，被拆分成一个个二进制帧。一个请求被拆分成多个帧，数据一帧帧的发往TCP传输层。多个请求之间不用相互等待，直接同时发，数据服务端也是一帧帧的解码，再把响应一帧帧的返回客户端，等到该请求的所有响应帧全部到达之后，就可以组装真正的响应报文了。





# 9.网络同源策略

**同源策略**在web应用的安全模型中是一个重要概念。在这个策略下，web浏览器允许第一个页面的脚本访问第二个页面里的数据，但是也只有在两个页面有相同的源时。源是由URI，主机名，端口号组合而成的。这个策略可以阻止一个页面上的恶意脚本通过页面的DOM对象获得访问另一个页面上敏感信息的权限。







### 1.如何规避同源策略的严格性？

1. js  jsonp函数
2. webSocket协议 使用WebSocket URI的时候，在请求中插入`Origin`头就可以标识脚本请求的源 
3. 代理服务器，用代理服务器返回不同源的策略。
4. 这种方式使用了一个新的`Origin`请求头和一个新的`Access-Control-Allow-Origin`响应头扩展了HTTP。允许服务端设置`Access-Control-Allow-Origin`头标识哪些站点可以请求文件，或者设置`Access-Control-Allow-Origin`头为"*"，允许任意站点访问文件。浏览器，例如Firefox3.5，Safari4，IE10使用这个头允许跨域HTTP请求。







# 10.linux网络指令

#### 1.ssh/scp

#### 2.ifconfig/netstat t(tcp)  p()  l

####3.