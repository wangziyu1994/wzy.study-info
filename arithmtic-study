## 简单排序

### 1.冒泡排序

第一轮0~1 1~2  2~3 .。。。  两两比较交换交大的元素

第二轮 1~2  2~3.。。。  两两比较交换交大的元素

连续多轮，直至N-2~N结束。





## 2.插入排序

第一轮  0~N-1  0-1比较 选出较大元素交换位置    0~2选出较大元素交换位置  .。。。

第二轮  1~N-1  0-1比较 选出较大元素交换位置    0~2选出较大元素交换位置  .。。。

连续多轮，直至N-2~N结束。



## 3.选择排序

第一轮0~N-1 选出最小的元素 放置到0

第二轮0~N-2 选出最小的元素 放置到 1

连续多轮，直至0~1.







# #1.随机行为

#### 1.Math.random()    [0,1)范围内的等概率的数



#### 2.扩大范围等概率的数 (int)(Math.random()*X+i)



#### 3.给定任意数组等概率返回 0，1

```java 
    //等概率返回1-5的随机数 不能改
    public static int f() {
        return (int) (Math.random() * 5 + 1);
    }

    //让f()等概率的返回0,1
    public static int f1() {
        int f = 0;
        do {
            f = f();
        } while (f == 3);
        return f = f < 3 ? 0 : 1;
    }
```



#### 4.等概率返回[0,N]范围的数

1. 将[0,N] 用二进制位表示

2. 每一bit位等概率的返回0，1

3. 利用位运算求出等概率返回的最终值

	```java 
	//等概率返回0-7  用000-111表示 0-7  等概率表示每一位，那么就能等概率表示0-7
	    public static int f2() {
	        return (f1() << 2) + (f1() << 1) + (f1() << 0);
	    }
	
	```

	

#### 5.等概率返回[M,N]范围的数

1. 将[M,N] 转化位[0,N-M]
2. 利用等概率返回[0,X]范围的数转化





#### 6.将不等概率转换位等概率返回

1. 多次不等概率返回，列出多次的所有结果
2. 循环将所有不等概率的情况，重新返回，直至得出概率相等的结果

```java 
 // 你只能知道，x会以固定概率返回0和1，但是x的内容，你看不到！改变成等概率返回0,1
    public static int function1() {
        return Math.random() < 0.84 ? 0 : 1;
    }


    //改变成等概率返回0,1
    //思路：00 01 10 11    返回01  10的概率是相等的 遇到00  11重做
    public static int dealFunction1(){
        int res=0;
        do{
            res=function1();
        }while(res==function1());

        return res;
    }
```







## 2.二分法

### 1.有序数组，二分法查找是否存在元素

L,R 范围  取中点 M=(0+N)/2

如果 param的值大于arr[M]

L=mid+1

如果param的值小于arr[M]

R=mid-1

如果param的值等于arr[M]

返回M

如果L>R说明数组元素遍历完成，没有符合条件的元素

```java 
/**
     * 给定一个有序数组，给定任意一个数。返回数组中此数的位置。没有返回-1
     */
public static int midQryNum(int[] arr, int param) {
    if (arr == null || arr.length == 0) {
        return -1;
    }

    if (arr.length == 1) {
        return arr[0] == param ? 0 : -1;
    }

    int L = 0;
    int R = arr.length - 1;
    int mid = 0;
    while (L<=R) {
        mid = (L + R) / 2;

        if (arr[mid] == param) {
            return mid;
        }

        if (arr[mid] < param) {
            L = mid + 1;
        }
        else{
            R = mid - 1;
        }
    }
    return -1;
}
```





### 2.给定一个数，用二分法查找给定有序数组中>=该数的最左边的值   最右边的值？

1. 使用二分法[L,R]  M=(L+R)/2

2. 如果中间的值大于等于该数，记录中间的位置。继续循环二分

	L=M+1

3. 如果中间的值小于该数，直接下一次循环

	R=M-1

4. 跳出循环的条件是L>R 

 ```java 
 /**
     * 给定一个有序数组，给定任意一个数。返回数组中>=此数的第一个数。没有返回-1
     * @return
     */
    public static int  firstLowerNum(int[] arr,int num) {
        if (arr == null || arr.length == 0) {
            return -1;
        }

        if (arr.length == 1) {
            return arr[0] >= num ? 0 : -1;
        }

        int mid = 0;
        int L = 0;
        int R = arr.length-1;
        int temp=-1;

        while (L <= R) {
            mid = (L + R) / 2;
            if (arr[mid] >= num) {
                temp=mid;
                R = mid - 1;
            } else if (arr[mid] < num) {
                L = mid + 1;
            }
        }
        return temp;
    }

 ```



### 3.整体无序，相邻不等 求出任意一个局部最小值

1. 如果arr[0]<arr[1]  0就是 局部最小  0左边没数，如果arr[N-1]<arr[N-2]  N-1 局部最小  N-1右边没数
2. **如果 arr[0]>arr[1]  且arr[N-1]>arr[N-2]  则[0,N-1]范围必定存在局部最小值 **

2. 取M=(L+N)/2   如果arr[M]<arr[M-1]且arr[M]<arr[M+1]    则arr[M]就是局部最小值

3. 如果 arr[M]>arr[M-1]那么[0,M]必定存在局部最小值  

	反之如果arr[M]>arr[M+1]那么[0,M]必定存在局部最小值

5. 循环跳出条件是 L>R 知道最终只剩下2个数





## 3.时间复杂度

1. 冒泡排序的时间复杂度是O（N平方)
2. 二分法时间复杂度是log2 N
3. java arrlist动态数组扩容的时间复杂度是O（1）



## 4.链表

**注意返回head或者tail  防止根不可达，整个链表被GC回收**

#### 1.单向链表

node1--------->node2----------->node3------------>null

换向问题: 

beforeNextNode=node.next

 beforeNextNode.next=node

#### 2.双向链表

null<--------node1<--------->node2<----------->node3<------------>null

**注意双向链表poll 方法是 去掉某个节点的时候，要让此节点的根不可达，让他被GC回收，防止内存泄漏**

换向问题

beforeNextNode=node.next;

beforePreNode=node.pre;

node.next=beforePreNode;

node.pre=beforeNextNode;



#### 3.  给定两个单向链表的头节点 head1  head2,两个链表相加,返回相加之后的链表

1. 必定有长链表 短链表。所以要计算出链表的长度 len1 len2 
2. 再长链表与短链表重合的部分，运算求和。
3. 求和势必出现进1，设置变量保存进1.
4. 后续运算一次增添进1
5. 两个链表对应节点相加 



## 5.位图

位运算前置知识：

1. 2的倍数整除 相乘 可以等同于2进制的为运算，除以2的n次方 等于左移n位，类比十进制 10的倍数整除 相乘

2. 2的倍数取模 可以等同于2的倍数-1的与运算 类比十进制的10的倍数的取模，去掉10的倍数的前几位，保留10的倍数的位数就是最后的余数。

	

#### 1.如何构造位图，表示所有的数

1. 一个8位的二进制数 可以表示0-63的十进制数
2. 可以用long 64位的二进制来表示0-63位的数，依次类推 64-127填充到long数组当中 .。。。
3. 对于任意一个数/64可以得知此数应处于数组的第几位。以0开始。
4. 对于任意一个数%64可以得知此数在数组[i]当中第N个二进制位表示1







#### 2.二进制位运算实现加减乘除

1. 加

	两数异或 得出不进位相加后的数  

	两数与 得出需要进位的数，在左移一位，得出单纯进位的数

	上述两数相加得出最终加的数.

	若第一次得出异或 和左移 进位的数之后，循环反复，知道进位数为0 ，那么最后的无进制的数就是相加后的数

	

2. 减

	一个数加上另一数的负数  负数=原数取反+1

3. 乘

	被乘数的每一位乘上乘数 的积(第几位要左移几位)相加.

	如果被乘数的二进制位上为0则不用计算。如果为1，则加上乘数的左移位后的数

	通过被乘数与1做与运算求出被乘数第一位数，之后被乘数每次无符号右移一位，直至被乘数为0结束。

4. 除

​      除数一直减被除数  连减，知道除数减到小于被减数的时候，总的减的次数就是商。







## 6.比较器，优先级队列

####1.compare 返回-1 左边元素的位置靠前，1左边元素的位置靠后



#### 2.优先级队列分为根小堆队列，根大堆队列

1. 小堆队列每次弹出的都是位置靠前的元素
2. 大堆队列每次弹出的都是位置靠后的元素



#### 3.多顺序链表 合并成一个有序链表

1. 把所有链表的Head元素全部放入根小堆队列
2. 遍历弹出根小堆队列的元素，依次串连每个元素。







## 7.二叉树

#### 1.求出二叉树最大深度

1.当前节点如果不为空，返回1，否则返回0

2.分别递归调用上一方法，传入参数左下节点 以及右下节点。取两个的最大值。







## 8.归并排序

1. 对半拆分数组  把前半部分排序完成，再把后半部分排序完成。
2. 创建临时数组。用于存放合并后的数组
3. 两个有序的数组比较对应元素，小的放在新数组前面，大的放在后面，依次存入。
4. 对同一数组递归采用此方法。



#### 第二种思路解法

1. 设置距离1开始 分组 合并排序保证所有左组的数都比右组的数小，右组无，不管。右组的数不够继续合并。
2. 设置距离2 开始分组  合并排序保证所有左组的数都比右组的数小
3. 设置距离4 开始分组  合并排序保证所有左组的数都比右组的数小
4. 直到距离为数据的长度N-1或者比它大



## 9.快速排序

1. 选出数组中的任意一个数作为比对数，一般选首个元素记作  base=arr[0]
2. 设置左指针left=0,设置右指针right=length-1
3. 从右往左遍历,右指针不断左移，找到第一个比base 小的数，交换arr[right],arr[left]，直到right=left
4. 从左往右遍历,左指针不断右移，找到第一个比base 大的数,  交换arr[left],arr[right],直到left=right