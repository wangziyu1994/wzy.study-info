## 1.jdk ArrayList的的底层实现

1. jdk1.7  int size  [] elementData  初始化ArrayList  默认初始化一个长度为10的Object数组

每次添加一个元素size加1，当size大于数组的长度时，复制一个原数组1.5倍的新数组。

2. jdk1.8   int size  [] elementData  初始化ArrayList  默认初始化一个长度为0的Object数组

	当第一次调用add方法时，将空数组变为长度为10的数组,每次添加一个元素size加1，当size大于数组的长度时，复制一个原数组1.5倍的新数组.



#### 2.Object 的hashCode()方法

1. 把一个数通过一定算法（取余法......），计算出的值的长度固定。那么这种算法称作hash函数

2. 得出的值称作hashCode 也叫散列码。
3. jdk中的hashCode 通过对象的内存地址加hash算法得出的一个散列码.



##2.jdk HashMap的底层实现

### 1.jdk1.7

1. 数组加链表

2. 头擦法

3. 1.7扩容的死循环问题

	1. 多线程环境下

	2. thread1 插入元素，发现容量达到扩容条件,新建新数组，将所有的元素遍历，重hash插入到新数组的过程，并且完成复制的流程

	3. 因为采用的是头插法，如下

		在遍历发生hash碰撞的链表中，首先会把原元素的下一指向指向当前数组的位置，再把原元素放入新数组当中，再进行下一次循环。此时A--------》A1-------->null的链表关系会变为

		A1------------------》A---------》null

		```java 
		 void resize(int newCapacity) {  
		        Entry[] oldTable = table;//老的数据  
		        int oldCapacity = oldTable.length;//获取老的容量值  
		        if (oldCapacity == MAXIMUM_CAPACITY) {//老的容量值已经到了最大容量值  
		            threshold = Integer.MAX_VALUE;//修改扩容阀值  
		            return;  
		        }  
		        //新的结构  
		        Entry[] newTable = new Entry[newCapacity];  
		        transfer(newTable, initHashSeedAsNeeded(newCapacity));//将老的表中的数据拷贝到新的结构中  
		        table = newTable;//修改HashMap的底层数组  
		        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);//修改阀值  
		    }  
		\\========================================================================
		    //将老的表中的数据拷贝到新的结构中  
		    void transfer(Entry[] newTable, boolean rehash) {  
		        int newCapacity = newTable.length;//容量  
		        for (Entry<K,V> e : table) { //遍历所有桶
		            while(null != e) {  //遍历桶中所有元素（是一个链表）
		                Entry<K,V> next = e.next;  
		                if (rehash) {//如果是重新Hash，则需要重新计算hash值  
		                    e.hash = null == e.key ? 0 : hash(e.key);  
		                }  
		                int i = indexFor(e.hash, newCapacity);//定位Hash桶  
		                e.next = newTable[i];//元素连接到桶中,这里相当于单链表的插入，总是插入在最前面
		                newTable[i] = e;//newTable[i]的值总是最新插入的值
		                e = next;//继续下一个元素  
		            }  
		        }  
		    }  
		
		```

		

	4. thread2 插入元素，发现容量达到扩容条件,也会把原元素的下一指向指向当前数组的位置，再把原元素放入新数组当中，再进行下一次循环。但此时新数组hash碰撞的链表关系已经变为

		A1------------------》A---------》null，而老数组的hash碰撞的第一位依然是A  之后把A的下一节点指向数组元素也就是A1，再将A位置放入新数组位置的元素，那么此时A的next为A1，而A1的next为A 此时就会变为A<--------------------->A1无限循环下去

		

		

### 2.jdk1.8

1. 数组加链表加红黑树
2. 尾插法

##### 具体实现

1. 首先初始化hashMap,默认一个扩容因子0.75

2. put 的hash方法 拿到当前对象的hashCode 做二次散列，扰动函数，得到一个h 后面存放到数组h的位置

	```java 
	   public V put(K key, V value) {
	        //hash方法二次散列加扰动函数，减少hash碰撞的频率
	        return putVal(hash(key), key, value, false, true);
	    }
	//========================================================
	static final int hash(Object key) {
	        int h;
	        //h = key.hashCode()) ^ (h >>> 16  二次hash 加散列
	        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
	    }
	\\============================================================
	```

	

3. 第一次进入，初始容量为0，数组为null，所以需要初始一个数组

```java 
 if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
\\==================================================================================
     //数组长度为0时指定数组的长度为16，再次扩容的瓶颈为16*0.75=12
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
\\=================================================================================
     //指定扩容瓶颈
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
                //新建扩容数组
            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        table = newTab;
  return newTab;
```



4. 根据hash& 数组长度 求出此元素应放在数组的哪一个位置比较合适。前提是此处元素不能有值

(n-1)&hash() 是一种hash算法，如果n为2的次幂的话，那么相当于%取模，得出来的值就是Hash值,此种算法要求n 为2^n次方的数 

```java 
//(n - 1) & hash 位的与运算，根据hash求出应该放在数组的哪一个位置上比较合适，前提此位置无元素
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);

```







5. 如果此处发生hash碰撞，计算出来的hash值相同，判断此处的键和插入元素的键对象的地址相同，或者非空对象equals方法返回true,就用新值替换旧值.

```java 
 //如果此处的元素的hash和插入元素的hash相同,且（此处的键和插入元素的键对象的地址相同，或者非空对象equals方法返回true)
            //那么就将此处元素的node对象暂存到e
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
\\==========================================================================
    //如果暂存对象的值不为空
            if (e != null) { // existing mapping for key
                //把原位置节点的值 暂存到V
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    //把原位置节点的值替换为新值
                    e.value = value;
                afterNodeAccess(e);
                //返回旧值
                return oldValue;
            }
        }
```



6.  如果此处发生hash碰撞,计算出来的hash值不同.

	遍历此处位置的链表,

	如果链表位置的所有元素都和插入元素不同，就直接把当前元素插入原链表的最后一个位置

	如果链表位置有任意节点满足插入元素的键对象的地址相同，或者非空对象equals方法返回true,就用新值替换旧值.如果链表的长度到达7了，就开始树化.

```java 
 else {
                //无限循环
                for (int binCount = 0; ; ++binCount) {
                    //如果原位置的节点的后面没有元素的话
                    if ((e = p.next) == null) {
                        //直接把插入元素放入原元素的下一个位置
                        p.next = newNode(hash, key, value, null);
                        //如果循环的次数到达第8次也就是原位置的链表已经有7个元素的话，开始树化
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    //再次判断原位置链表的对象是否和插入元素的hash值相等，（此处的键和插入元素的键对象的地址相同，或者非空对象equals方法返回true)
                    //是的话把原位置节点暂存到e
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        //判断是统一元素，覆盖旧值
                        break;
                    p = e;
                }
            }
```

7. hashMap扩容的方法:

	1. 如果数组元素达到容量的0.75时开始扩容。扩容长度为原数组的左移2位

		```java 
		        //如果数组的容量超过了0.75*容量（初始16）进行扩容
		        if (++size > threshold)
		            resize();
		//================================================================
		//新数组长度为原有数组左移以为即*2  新数组长度不能大于规定的最大长度，并且就有数组长度要大于等于 默认原始容量16
		            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
		                     oldCap >= DEFAULT_INITIAL_CAPACITY)
		                //新数组的扩容瓶颈为旧瓶颈的左移以为即使 12*2 24
		                newThr = oldThr << 1; // double threshold
		        }
		//=======================================================
		 //指定扩容瓶颈
		        threshold = newThr;
		        @SuppressWarnings({"rawtypes","unchecked"})
		                //新建扩容数组
		            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
		        table = newTab;
		        //如果超过初始化数组长度的话，进行扩容
		        if (oldTab != null) {
		            for (int j = 0; j < oldCap; ++j) {
		                Node<K,V> e;
		                //将原有数组的位置值暂存到e
		                if ((e = oldTab[j]) != null) {
		                    //将原有数组的位置元素至为null
		                    oldTab[j] = null;
		                    //如果原有数组位置的元素没有一个元素的话
		                    if (e.next == null)
		                        //重新hash,e.hash & (newCap - 1)直接求得该元素的hash值，将原有元素，放入新数组的位置中
		                        newTab[e.hash & (newCap - 1)] = e;
		                    else if (e instanceof TreeNode)
		                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
		                    //如果原有数组位置的元素还有下一个元素的话，采用高效算法算出hash值遍历，
		                    //e.hash & oldCap的取出的值如果为0位置不变，取出的值如果为1位置为当前位置 + oldCap
		                    else
		                    { // preserve order
		                        Node<K,V> loHead = null, loTail = null;
		                        Node<K,V> hiHead = null, hiTail = null;
		                        Node<K,V> next;
		                        do {
		                            next = e.next;
		                            if ((e.hash & oldCap) == 0) {
		                                //首位低位元素赋值
		                                if (loTail == null)
		                                    loHead = e;
		                                //后续低位元素赋值
		                                else
		                                    loTail.next = e;
		                                //更新末尾元素
		                                loTail = e;
		                            }
		                            else {
		                                //首位高位元素赋值
		                                if (hiTail == null)
		                                    hiHead = e;
		                                //后续高位元素赋值
		                                else
		                                    hiTail.next = e;
		                                //更新高位末尾元素
		                                hiTail = e;
		                            }
		                            //遍历原位置所有链表元素
		                        } while ((e = next) != null);
		                        //最后一位低位元素取完，节点串联完
		                        if (loTail != null) {
		                            //更新最后一位低位元素取完的下一位元素为0
		                            loTail.next = null;
		                            //把低位首位元素放入数组
		                            newTab[j] = loHead;
		                        }
		                        //最后一位高位元素取完，节点串联完
		                        if (hiTail != null) {
		                            //更新最后一位高位元素取完的下一位元素为0
		                            hiTail.next = null;
		                            //把高位首位元素放入数组
		                            newTab[j + oldCap] = hiHead;
		                        }
		                    }
		```

	
	



1,JAVA 强引用，软引用，弱引用，虚引用

1.1 强引用: 只有当对象没有被引用时，GC回收垃圾时开始回收此对象，否则不会被回收.

1.2 软引用: 只有当内存空间使用不足时，GC才会回收此对象,否则不会被回收.

1.3 弱引用: GC回收垃圾对象时，该对象就会被回收.

1.4 虚引用: 开辟在堆外的空间之内,任何时候都有可能被GC回收,在回收之前会被放入队列里面.



## 2.1.ConcurrentHashMap实现

#### 1.jdk1.7

##### a.new ConcurrentHashMap(int capacity)

默认容量16，扩容阈值比例0.75f 默认线程级别 16  其中currentcy_LEVEL最大65536

```java 
public ConcurrentHashMap() {
    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);
}
```



确定segment的数量 ssize永远是2的倍数

```java 
 while (ssize < concurrencyLevel) {
            ++sshift;
            ssize <<= 1;
        }
```



确定每个segment里面 HashEntry的数量 永远是2的倍数

```java 
        int c = initialCapacity / ssize;
        if (c * ssize < initialCapacity)
            ++c;
        int cap = 1;
        while (cap < c)
            cap <<= 1;
```



初始化segment的数组 的首位元素。之后segment的创建参数参考首位元素

```java 
     Segment<K,V> s0 =
            new Segment<K,V>(loadFactor, (int)(cap * loadFactor),
                             (HashEntry<K,V>[])new HashEntry[cap]);
        Segment<K,V>[] ss = (Segment<K,V>[])new Segment[ssize];
        UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
        this.segments = ss;
```



##### b.ConcurrentHashMap的put方法

1. hash()就是根据对象的hashCode 做二次散列

2. 这里的segmentshift 是31-sshift  sshift为高位0的个数  segmentMask为ssize-1  
3. j<<sshift+sbase实际就是取此元素应放入segment数组的位置下标，如果为空的需要添加的话，先确定是否扩容

```java 
 public V put(K key, V value) {
        Segment<K,V> s;
        if (value == null)
            throw new NullPointerException();
        int hash = hash(key);
        int j = (hash >>> segmentShift) & segmentMask;
        if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck
             (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment
            s = ensureSegment(j);
        return s.put(key, hash, value, false);
    }
```



4.ensureSegment(j)

使用UNSAFE 的CAS操作 两次check 看segment数组的位置是否已经有值，如果两次都无的话，再循环自旋赋值创建的新Segment元素.

```java 
   private Segment<K,V> ensureSegment(int k) {
        final Segment<K,V>[] ss = this.segments;
        long u = (k << SSHIFT) + SBASE; // raw offset
        Segment<K,V> seg;
        if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) {
            Segment<K,V> proto = ss[0]; // use segment 0 as prototype
            int cap = proto.table.length;
            float lf = proto.loadFactor;
            int threshold = (int)(cap * lf);
            HashEntry<K,V>[] tab = (HashEntry<K,V>[])new HashEntry[cap];
            if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))
                == null) { // recheck
                Segment<K,V> s = new Segment<K,V>(lf, threshold, tab);
                while ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))
                       == null) {
                    if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))
                        break;
                }
            }
        }
        return seg;
    }
```

5.拿到正确的segment元素，调用它的put方法，将元素放入它的HashEntry数组中

```java 
      HashEntry<K,V> node = tryLock() ? null :
                scanAndLockForPut(key, hash, value);
```

6.如果tryLock()  未获取锁的话先做准备工作，scanAndLockForPut()方法 ,entryForHash 获取该元素hash值计算出来在此HashEntry中的位置元素。

        ```java 
  HashEntry<K,V> first = entryForHash(this, hash);
        ```

7.设置重试次数retry,如果仍然没有获得锁的话，首先判断HashEntry上是否已存在此元素，如果没的话，创建出一个,设置retry=0 ,如果key 与equals相等的话，仍然设置retry=0,不是的话取e的下一节点进行比较

  如果超过重试次数的话，直接调用lock方法，进入同步队列等待。跳出循环

如果重试次数是0 的话并且HashEntry位置的元素发生改变的话，会再次导致循环。

**这里的主要作用是在别的线程占用ConcurrentHashMap的同时，当前线程提前创建好HashEntry对象。方便之后直接使用**

  

```java 
 int retries = -1; // negative while locating node
            while (!tryLock()) {
                HashEntry<K,V> f; // to recheck first below
                if (retries < 0) {
                    if (e == null) {
                        if (node == null) // speculatively create node
                            node = new HashEntry<K,V>(hash, key, value, null);
                        retries = 0;
                    }
                    else if (key.equals(e.key))
                        retries = 0;
                    else
                        e = e.next;
                }
                else if (++retries > MAX_SCAN_RETRIES) {
                    lock();
                    break;
                }
                else if ((retries & 1) == 0 &&
                         (f = entryForHash(this, hash)) != first) {
                    e = first = f; // re-traverse if entry changed
                    retries = -1;
                }
            }
```



8.put方法之后就是和HashMap的方法一样 key存在 新值替换旧值或者putIfabsent什么都不做。

扩容或者头插法串联旧有链表

```java 
  HashEntry<K,V> first = entryAt(tab, index);
                for (HashEntry<K,V> e = first;;) {
                    if (e != null) {
                        K k;
                        if ((k = e.key) == key ||
                            (e.hash == hash && key.equals(k))) {
                            oldValue = e.value;
                            if (!onlyIfAbsent) {
                                e.value = value;
                                ++modCount;
                            }
                            break;
                        }
                        e = e.next;
                    }
                    else {
                        if (node != null)
                            node.setNext(first);
                        else
                            node = new HashEntry<K,V>(hash, key, value, first);
                        int c = count + 1;
                        if (c > threshold && tab.length < MAXIMUM_CAPACITY)
                            rehash(node);
                        else
                            setEntryAt(tab, index, node);
                        ++modCount;
                        count = c;
                        oldValue = null;
                        break;
                    }
                }
```



segmentFor().put()正式将对象放入HashEntry数组当中

```java 
V put(K key, int hash, V value, boolean onlyIfAbsent) {
            lock();//ReenTrantLock put锁
            try {
                int c = count;
                //如果超过容量，扩容，rehash
                if (c++ > threshold) // ensure capacity
                    rehash();
                HashEntry<K,V>[] tab = table;
                //根据hash值计算出索引
                int index = hash & (tab.length - 1);
                HashEntry<K,V> first = tab[index];
                HashEntry<K,V> e = first;
                //遍历数组元素及其后续链表节点，比对hash值或者 equals方法是否相同。相同判断为同一对象，key不变，新值替换旧值
                while (e != null && (e.hash != hash || !key.equals(e.key)))
                    e = e.next;

                V oldValue;
                //新值替换旧值
                if (e != null) {
                    oldValue = e.value;
                    if (!onlyIfAbsent)
                        e.value = value;
                }
                //重新
                else {
                    oldValue = null;
                    ++modCount;
                    tab[index] = new HashEntry<K,V>(key, hash, first, value);
                    count = c; // write-volatile
                }
                return oldValue;
            } finally {
                unlock();
            }
        }
```



 rehash()方法，或对原有元素进行重新hash并且将所有内容复制到新的数组当中

1.先判断就的HashEntry数组位置是否存在链表，没有的话，直接赋值数组

2.如果存在的话，遍历链表，把与尾节点hash值一样的连续节点，取出，直接放入新数组中

   如果除了与尾节点hash值相同的连续节点之外的其他散列节点依次放入新的数组中

3.扩容赋值完成之后，再把新的节点放入新的HashEntry数组当中

```java 
       int sizeMask = newCapacity - 1;
            for (int i = 0; i < oldCapacity ; i++) {
                HashEntry<K,V> e = oldTable[i];
                if (e != null) {
                    HashEntry<K,V> next = e.next;
                    int idx = e.hash & sizeMask;
                    if (next == null)   //  Single node on list
                        newTable[idx] = e;
                    else { // Reuse consecutive sequence at same slot
                        HashEntry<K,V> lastRun = e;
                        int lastIdx = idx;
                        for (HashEntry<K,V> last = next;
                             last != null;
                             last = last.next) {
                            int k = last.hash & sizeMask;
                            if (k != lastIdx) {
                                lastIdx = k;
                                lastRun = last;
                            }
                        }
                        newTable[lastIdx] = lastRun;
                        // Clone remaining nodes
                        for (HashEntry<K,V> p = e; p != lastRun; p = p.next) {
                            V v = p.value;
                            int h = p.hash;
                            int k = h & sizeMask;
                            HashEntry<K,V> n = newTable[k];
                            newTable[k] = new HashEntry<K,V>(h, p.key, v, n);
                        }
                    }
                }
            }
```



##### c.ConcurrentHashMap的get方法

1.根据hash值先算出key所在的Segment数组中的位置，再CAS直接取出值

2.根据hash值算出key所在的HashEntry中数组中的位置，CAS取出元素值，如果地址相同或者hash值，并且equals相同直接返回key的值，否则返回null

```java 
public V get(Object key) {
    Segment<K,V> s; // manually integrate access methods to reduce overhead
    HashEntry<K,V>[] tab;
    int h = hash(key);
    long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;
    if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&
        (tab = s.table) != null) {
        for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile
             (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);
             e != null; e = e.next) {
            K k;
            if ((k = e.key) == key || (e.hash == h && key.equals(k)))
                return e.value;
        }
    }
    return null;
}

```





#### 2.jdk1.8

##### a.new ConcurrentHashMap(int capacity)方法

设置内部数组的容量为2的倍数

```java 
  public ConcurrentHashMap(int initialCapacity) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException();
        int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?
                   MAXIMUM_CAPACITY :
                   tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));
        this.sizeCtl = cap;
    }
```





##### b.ConcurrentHashMap的put方法

1.如果数组未初始化的话，初始化数组

2.自旋 CAS设置sizectl为-1 只有设置成功的话才有资格初始化数组，如果已经被修改为-1的话，其他线程Thread.yield，让出CPU执行权 重新循环竞争。直到数组被初始化

```java 
private final Node<K,V>[] initTable() {
        Node<K,V>[] tab; int sc;
        while ((tab = table) == null || tab.length == 0) {
            if ((sc = sizeCtl) < 0)
                Thread.yield(); // lost initialization race; just spin
            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                try {
                    if ((tab = table) == null || tab.length == 0) {
                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                        @SuppressWarnings("unchecked")
                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                        table = tab = nt;
                        sc = n - (n >>> 2);
                    }
                } finally {
                    sizeCtl = sc;
                }
                break;
            }
        }
        return tab;
    }
```





2.如果数组原先位置的值为null的话直接，赋值

```java 
 else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                if (casTabAt(tab, i, null,
                             new Node<K,V>(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
```







3.如果数组原先位置的有值的话,那么发生hash冲突，此时需要串联链表，或者升级为红黑树，为了防止并发问题使用synchronized同步块。逻辑和HashMap基本相同。如果为相同元素，新值替换旧值。如果为不同元素，添加新的元素。

**不同的时，如果是红黑树的话，那么数组当中存放的不是TreeNode节点，而是TreeBin节点。原因是，红黑树在发生修改的时候，很可能发生根节点的旋转。而在树化的代码是不在同步代码块的，所以使用一个包装类包装红黑树的节点。这样即使红黑树的头节点发生旋转，这个包装类永远不会发生变化，因此树化同步的锁，不会发生改变**

```java 
synchronized (f) {
    if (tabAt(tab, i) == f) {
        if (fh >= 0) {
            binCount = 1;
            for (Node<K,V> e = f;; ++binCount) {
                K ek;
                if (e.hash == hash &&
                    ((ek = e.key) == key ||
                     (ek != null && key.equals(ek)))) {
                    oldVal = e.val;
                    if (!onlyIfAbsent)
                        e.val = value;
                    break;
                }
                Node<K,V> pred = e;
                if ((e = e.next) == null) {
                    pred.next = new Node<K,V>(hash, key,
                                              value, null);
                    break;
                }
            }
        }
        else if (f instanceof TreeBin) {
            Node<K,V> p;
            binCount = 2;
            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                  value)) != null) {
                oldVal = p.val;
                if (!onlyIfAbsent)
                    p.val = value;
            }
        }
    }
}
```



4.addCount(1,bitcount)方法

如果 counterCell未初始化  如果CAS  baseCount失败说明有竞争

```java 
if ((as = counterCells) != null ||
            !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) 
```



如果countCell未初始化   如果countCell  里面的cell未初始化   如果CAS cell 里面的value失败 说明有竞争

```java 
   if (as == null || (m = as.length - 1) < 0 ||
                (a = as[ThreadLocalRandom.getProbe() & m]) == null ||
                !(uncontended =
                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) 
```



5.fullCount(1,uncontended)方法 和LongAddr处理并发问题的实现一样

```java 

```





##### c.ConcurrentHashMap的扩容方法Transfer

如果put发现当前位置正在转移的话，那么put线程会先帮助完成转移，之后再put

```java 
//==============================putVal()=======================
else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
//=============================helpTransfer=================================
final Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) {
        Node<K,V>[] nextTab; int sc;
        if (tab != null && (f instanceof ForwardingNode) &&
            (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) {
            int rs = resizeStamp(tab.length);
            while (nextTab == nextTable && table == tab &&
                   (sc = sizeCtl) < 0) {
                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || transferIndex <= 0)
                    break;
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {
                    transfer(tab, nextTab);
                    break;
                }
            }
            return nextTab;
        }
        return table;
    }
```



1.确定当前线程扩容的步长，最小16  16个hash桶由当前线程转移至新数组。如果新数组为空，初始化一个扩容2倍的数组

```java 
 int n = tab.length, stride;
        if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)
            stride = MIN_TRANSFER_STRIDE; // subdivide range
        if (nextTab == null) {            // initiating
            try {
                @SuppressWarnings("unchecked")
                Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];
                nextTab = nt;
            } catch (Throwable ex) {      // try to cope with OOME
                sizeCtl = Integer.MAX_VALUE;
                return;
            }
            nextTable = nextTab;
            transferIndex = n;
        }
```



2.这里就是给当前线程划分分工范围 bound-i    cas修改transferIndex 发生并发时方便给别的线程也划分相应的分工范围   .

这里如果当前线程的范围转移完了的话，还有别的范围需要转移，那么会继续转移。

```java 
int nextn = nextTab.length;
        ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);
        boolean advance = true;
        boolean finishing = false; // to ensure sweep before committing nextTab
        for (int i = 0, bound = 0;;) {
            Node<K,V> f; int fh;
            while (advance) {
                int nextIndex, nextBound;
                if (--i >= bound || finishing)
                    advance = false;
                else if ((nextIndex = transferIndex) <= 0) {
                    i = -1;
                    advance = false;
                }
                else if (U.compareAndSwapInt
                         (this, TRANSFERINDEX, nextIndex,
                          nextBound = (nextIndex > stride ?
                                       nextIndex - stride : 0))) {
                    bound = nextBound;
                    i = nextIndex - 1;
                    advance = false;
                }
            }
```



3.如果旧数组元素为空，这是ForwardingNode对象，标识下，表明当前范围的正在扩容，暂时不能添加元素

 如果旧数组元素不为空的话,那么synchronize 加上当前位置数组元素的锁，与put方法用的同样的锁，目的就是防止出现put 与转移的并发。这样就能保证线程安全，让先put完，再扩容，或者先扩容完，再put.

这里的链表转移  先从末尾 找到连续的高位元素，直接移到新数组，之后依次分别串联剩下的高位元素，地位元素。转移到新数组。

```java 
 else if ((f = tabAt(tab, i)) == null)
                advance = casTabAt(tab, i, null, fwd);
            else if ((fh = f.hash) == MOVED)
                advance = true; // already processed
            else {
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        Node<K,V> ln, hn;
                        if (fh >= 0) {
                            int runBit = fh & n;
                            Node<K,V> lastRun = f;
                            for (Node<K,V> p = f.next; p != null; p = p.next) {
                                int b = p.hash & n;
                                if (b != runBit) {
                                    runBit = b;
                                    lastRun = p;
                                }
                            }
                            if (runBit == 0) {
                                ln = lastRun;
                                hn = null;
                            }
                            else {
                                hn = lastRun;
                                ln = null;
                            }
                            for (Node<K,V> p = f; p != lastRun; p = p.next) {
                                int ph = p.hash; K pk = p.key; V pv = p.val;
                                if ((ph & n) == 0)
                                    ln = new Node<K,V>(ph, pk, pv, ln);
                                else
                                    hn = new Node<K,V>(ph, pk, pv, hn);
                            }
                            setTabAt(nextTab, i, ln);
                            setTabAt(nextTab, i + n, hn);
                            setTabAt(tab, i, fwd);
                            advance = true;
                        }
                        else if (f instanceof TreeBin) {
                            TreeBin<K,V> t = (TreeBin<K,V>)f;
                            TreeNode<K,V> lo = null, loTail = null;
                            TreeNode<K,V> hi = null, hiTail = null;
                            int lc = 0, hc = 0;
                            for (Node<K,V> e = t.first; e != null; e = e.next) {
                                int h = e.hash;
                                TreeNode<K,V> p = new TreeNode<K,V>
                                    (h, e.key, e.val, null, null);
                                if ((h & n) == 0) {
                                    if ((p.prev = loTail) == null)
                                        lo = p;
                                    else
                                        loTail.next = p;
                                    loTail = p;
                                    ++lc;
                                }
                                else {
                                    if ((p.prev = hiTail) == null)
                                        hi = p;
                                    else
                                        hiTail.next = p;
                                    hiTail = p;
                                    ++hc;
                                }
                            }
                            ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
                                (hc != 0) ? new TreeBin<K,V>(lo) : t;
                            hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
                                (lc != 0) ? new TreeBin<K,V>(hi) : t;
                            setTabAt(nextTab, i, ln);
                            setTabAt(nextTab, i + n, hn);
                            setTabAt(tab, i, fwd);
                            advance = true;
                        }
                    }
```





4.判断数组的转移是否完成

i < 0 || i >= n || i + n >= nextn  说明当前线程的范围已经转移完毕。

cas将sizectl 减1 之后判断所有线程是否已经转移完毕。如果是的话，之后会用新数组替代老数组，并且设置sizeCTL的值为0.75*当前数组的容量。

```java 
if (i < 0 || i >= n || i + n >= nextn) {
                int sc;
                if (finishing) {
                    nextTable = null;
                    table = nextTab;
                    sizeCtl = (n << 1) - (n >>> 1);
                    return;
                }
                if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {
                    if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)
                        return;
                    finishing = advance = true;
                    i = n; // recheck before commit
                }
            }
```



##### d.ConcurrentHashMap的get方法

根据hash值查找，遍历 红黑树或者链表  如果找到直接返回，否则返回null

```Java 
public V get(Object key) {
        Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
        int h = spread(key.hashCode());
        if ((tab = table) != null && (n = tab.length) > 0 &&
            (e = tabAt(tab, (n - 1) & h)) != null) {
            if ((eh = e.hash) == h) {
                if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                    return e.val;
            }
            else if (eh < 0)
                return (p = e.find(h, key)) != null ? p.val : null;
            while ((e = e.next) != null) {
                if (e.hash == h &&
                    ((ek = e.key) == key || (ek != null && key.equals(ek))))
                    return e.val;
            }
        }
        return null;
    }
```







##3.代理

#### 3.1 静态代理



#### 3.2 动态代理

##### 3.2.1 JDK动态代理

1. JDK动态代理底层的实现原理是运行时产生一个Class,此Class继承Proxy 并且实现了 传递的给定接口，因此JDK的动态代理只能对接口实现动态代理，而不能对类进行代理
2. 此类有一个构造器，构造器的参数是InvocationHandler 并且此类有一个属性是InvocationHandler,此类还有四个静态属性，分别是Object的 equals,hashCode,toString 以及接口的实现方法Method.静态代码块会初始化这四个属性.此类有一个final方法为实现接口的重写方法.这个重写方法用InvocationHandler的属性值调用了invoke(this,method,args[]) 方法 ,其中this 是当前代理对象,method为接口的实现方法，args[]为重写方法的参数 .因此你可以再invoke里做任何操作。在调用代理对象的重写方法来达到调用目标对象重写方法的目的

```java  

public final class $Proxy0 extends Proxy implements Person
{
  private static Method m1;
  private static Method m2;
  private static Method m3;
  private static Method m0;
  
  /**
  *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，看到这，是不是就有点明白
  *为何代理对象调用方法都是执行InvocationHandler中的invoke方法，而InvocationHandler又持有一个
  *被代理对象的实例，不禁会想难道是....？ 没错，就是你想的那样。
  *
  *super(paramInvocationHandler)，是调用父类Proxy的构造方法。
  *父类持有：protected InvocationHandler h;
  *Proxy构造方法：
  *    protected Proxy(InvocationHandler h) {
  *         Objects.requireNonNull(h);
  *         this.h = h;
  *     }
  *
  */
  public $Proxy0(InvocationHandler paramInvocationHandler)
    throws 
  {
    super(paramInvocationHandler);
  }
  
  //这个静态块本来是在最后的，我把它拿到前面来，方便描述
   static
  {
    try
    {
      //看看这儿静态块儿里面有什么，是不是找到了giveMoney方法。请记住giveMoney通过反射得到的名字m3，其他的先不管
      m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[] { Class.forName("java.lang.Object") });
      m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);
      m3 = Class.forName("proxy.Person").getMethod("giveMoney", new Class[0]);
      m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);
      return;
    }
    catch (NoSuchMethodException localNoSuchMethodException)
    {
      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());
    }
    catch (ClassNotFoundException localClassNotFoundException)
    {
      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());
    }
  }
 
  /**
  * 
  *这里调用代理对象的giveMoney方法，直接就调用了InvocationHandler中的invoke方法，并把m3传了进去。
  *this.h.invoke(this, m3, null);这里简单，明了。
  *来，再想想，代理对象持有一个InvocationHandler对象，InvocationHandler对象持有一个被代理的对象，
  *再联系到InvacationHandler中的invoke方法。嗯，就是这样。
  */
  public final void giveMoney()
    throws 
  {
    try
    {
      this.h.invoke(this, m3, null);
      return;
    }
    catch (Error|RuntimeException localError)
    {
      throw localError;
    }
    catch (Throwable localThrowable)
    {
      throw new UndeclaredThrowableException(localThrowable);
    }
  }

  //注意，这里为了节省篇幅，省去了toString，hashCode、equals方法的内容。原理和giveMoney方法一毛一样。

}
```



3. 实现JDK动态代理的方法有两种

	```java  
	public class MyInvocationInteceptor implements InvocationHandler {
	    private MyInterface target;
	
	    public MyInvocationInteceptor(MyInterface myInterface) {
	        this.target = myInterface;
	    }
	
	    @Override
	    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
	        System.out.println("开始执行MyInvocationInceptor方法");
	        System.out.println("代理对象的类对象是"+proxy.getClass());
	        System.out.println("代理对象代理的方法名是"+method.getName());
	        System.out.println("开始执行dosomething方法");
	        Object result=method.invoke(target,args);
	        return result;
	    }
	}
	
	\\========================================================================
	    
	public class JdkDynamicProxyTest {
	    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
	        InvocationHandler it=new MyInvocationInteceptor((o1,o2)->{
	            return "目标对象方法的返回值1";
	        });
	        Object proxyObject=Proxy.newProxyInstance(MyInterface.class.getClassLoader(),new Class[]{MyInterface.class},it);
	        MyInterface proxyObject1=(MyInterface)proxyObject;
	        String result=(String)proxyObject1.dosomething("1","a");
	        System.out.println(result);
	
	
	        Class<?> proxyClass=Proxy.getProxyClass(MyInterface.class.getClassLoader(),MyInterface.class);
	        Constructor<?> constructor=proxyClass.getConstructor(InvocationHandler.class);
	        MyInterface proxyObject2=(MyInterface) constructor.newInstance(new MyInvocationInteceptor((o1,o2)->{
	            return "目标对象方法的返回值2";
	        }));
	        String result1=(String) proxyObject2.dosomething("1","b");
	        System.out.println(result1);
	
	
	
	
	    }
	}
	\\==========================================================================
	    
	```

	3.2.1.1 源码分析
	
	
	
	```java 
	Class<?> cl = getProxyClass0(loader, intfs);
	//==================================================
	private static Class<?> getProxyClass0(ClassLoader loader,
	                                       Class<?>... interfaces) {
	    if (interfaces.length > 65535) {
	        throw new IllegalArgumentException("interface limit exceeded");
	    }
	
	    // If the proxy class defined by the given loader implementing
	    // the given interfaces exists, this will simply return the cached copy;
	    // otherwise, it will create the proxy class via the ProxyClassFactory
	    return proxyClassCache.get(loader, interfaces);
	}
	//======================================
	try {
	    value = Objects.requireNonNull(valueFactory.apply(key, parameter));
	} final
	    //=======================================
	
	    //核心代码块 生成代理类的字节码文件，并且加载到内存成为对应的Class对象
	    @Override
	    public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {
	
	    Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);
	    for (Class<?> intf : interfaces) {
	        /*
	                 * Verify that the class loader resolves the name of this
	                 * interface to the same Class object.
	                 */
	        Class<?> interfaceClass = null;
	        try {
	            interfaceClass = Class.forName(intf.getName(), false, loader);
	        } catch (ClassNotFoundException e) {
	        }
	        if (interfaceClass != intf) {
	            throw new IllegalArgumentException(
	                intf + " is not visible from class loader");
	        }
	        /*
	                 * Verify that the Class object actually represents an
	                 * interface.
	                 */
	        if (!interfaceClass.isInterface()) {
	            throw new IllegalArgumentException(
	                interfaceClass.getName() + " is not an interface");
	        }
	        /*
	                 * Verify that this interface is not a duplicate.
	                 */
	        if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {
	            throw new IllegalArgumentException(
	                "repeated interface: " + interfaceClass.getName());
	        }
	    }
	
	    String proxyPkg = null;     // package to define proxy class in
	    int accessFlags = Modifier.PUBLIC | Modifier.FINAL;
	
	    /*
	             * Record the package of a non-public proxy interface so that the
	             * proxy class will be defined in the same package.  Verify that
	             * all non-public proxy interfaces are in the same package.
	             */
	    for (Class<?> intf : interfaces) {
	        int flags = intf.getModifiers();
	        if (!Modifier.isPublic(flags)) {
	            accessFlags = Modifier.FINAL;
	            String name = intf.getName();
	            int n = name.lastIndexOf('.');
	            String pkg = ((n == -1) ? "" : name.substring(0, n + 1));
	            if (proxyPkg == null) {
	                proxyPkg = pkg;
	            } else if (!pkg.equals(proxyPkg)) {
	                throw new IllegalArgumentException(
	                    "non-public interfaces from different packages");
	            }
	        }
	    }
	
	    if (proxyPkg == null) {
	        // if no non-public proxy interfaces, use com.sun.proxy package
	        proxyPkg = ReflectUtil.PROXY_PACKAGE + ".";
	    }
	
	    /*
	             * Choose a name for the proxy class to generate.
	             */
	    long num = nextUniqueNumber.getAndIncrement();
	
	    //代理类的类名
	    String proxyName = proxyPkg + proxyClassNamePrefix + num;
	
	    /*
	             * Generate the specified proxy class.
	             */
	    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
	        proxyName, interfaces, accessFlags);
	    try {
	        return defineClass0(loader, proxyName,
	                            proxyClassFile, 0, proxyClassFile.length);
	    } catch (ClassFormatError e) {
	        /*
	                 * A ClassFormatError here means that (barring bugs in the
	                 * proxy class generation code) there was some other
	                 * invalid aspect of the arguments supplied to the proxy
	                 * class creation (such as virtual machine limitations
	                 * exceeded).
	                 */
	        throw new IllegalArgumentException(e.toString());
	    }
	}
	}
	```
	
	总结：jdk  Proxy.newProxyInstance 中创建出一个字节码对象，该对象继承Proxy类 并且有一个属性时用户设置的InvocationIntercepter对象.
	
	他的静态属性是Object的所有方法以及代理的目标方法，他的静态代码块会将这些方法对象反射成Method对象。他有所有和目标对象同名的方法。并且里面会调用this.invocationInterceptor.invoke(代理对象,参数,null)
	
	方法，就是进入invocationIntercepter的invoke方法。 invoke方法会实际调用目标对象的方法逻辑。
	
	
	
	

##### 3.2.2 ciglib动态代理

```java 
//创建增强器对象，里面预设了一系列缓存        
Enhancer enhancer=new Enhancer();
//设置目标类
enhancer.setSuperclass(AInterface.class);
//设置回调
enhancer.setCallback(interceptor);
//核心创建出实际代理对象
AInterface aInterface=(AInterface)enhancer.create();
aInterface.function1("aInterface");
```





##4.ReenTrantLock-AQS源码分析

AQS-------->Sync------------>fairSync/noFairSync

1.首先lock()方法  调用sync 的lock()方法 sync默认实现是fairsysnc 可以指定为nofairsync

```java 
 public void lock() {
        sync.lock();
    }
//================================fairSync
     final void lock() {
            acquire(1);
        }
//================================noFairSync
 final void lock() {
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }

//=================================
```







2.公平锁，非公平锁都会进入 AQS的acquire方法

```JAVA 
//=============================== AQS的 acquire
   public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }

```



3.非公平锁 获取锁的过程不会考虑自己是否在队列以及是否要排队,但是在两次自旋获取失败之后，被加入队列之后，后续就和公平锁一样了。

```java 
   protected final boolean tryAcquire(int acquires) {
            return nonfairTryAcquire(acquires);
        }
//================================== 
final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
```



4.公平锁的tryAcquire方法

​    1.判断锁是否被占有，没占有的话判断是否处于竞争状态，有的话判断是否是重入

```java 
//============================ fairSync的tryAcquire方法========
protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
     //为0进入
            if (c == 0) {
                if (!hasQueuedPredecessors() &&
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
    //如果之前持有锁，可以重入
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0)
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
    }


```

​     2.hasQueuedPredecessors()方法 判断队列是否有节点已经在排队等待获取锁了 如果有了的话。入队。  acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 否则直接取得锁。这里考虑的情况非常多。

  1.h==t 

1. 队列没有初始化----------------》没有竞争条件，直接尝试获得锁，不用考虑入队问题，获取锁失败，再考虑入队获得锁

2.  队列只有一个节点，头尾节点相同

	  2.1 队列刚刚被初始化，head=tail时此时队列只有一个初始化的空节点。此时若正好有线程进入，那么也可以直接获得锁。



 2.h!=t 

​    1.head.next=null

   队列中只有两个节点。-----------》队列中有且只有一个线程节点正在排队，那么此线程节点完全有资格尝试获得锁。

​    2.head.next!=null,head.next.thread=Thread.currentThread

 队列中有两个以上节点,并且此时队列排队节点的首位节点就是当前线程节点，那么此线程节点完全由资格资格获得锁.

   3.head.next!=null,head.next.thread!=Thread.currentThread

 队列中有两个以上节点,并且此时队列排队节点的首位节点不是当前线程节点，那么当前线程节点只能去乖乖排队等待获取锁的资格

```java 
//=============================hasQueuedPredecessors方法====
  public final boolean hasQueuedPredecessors() {
        // The correctness of this depends on head being initialized
        // before tail and on head.next being accurate if the current
        // thread is first in queue.
        Node t = tail; // Read fields in reverse initialization order
        Node h = head;
        Node s;
        //h==t说明 队列未初始化head,tail都为null或者 head=tail刚刚初始化阶段
        return h != t &&
            ((s = h.next) == null || s.thread != Thread.currentThread());
    }
```



   3.addWaiter(Node.EXCLUSIVE), arg)方法

```JAVA  
   private Node addWaiter(Node mode) {
       //创建当前线程的节点Node
        Node node = new Node(Thread.currentThread(), mode);
       //获取当前AQS的tail节点，如果tail不为null说明队列已被初始化
       //如果tail不为Null则enq初始化AQS队列
        Node pred = tail;
        if (pred != null) {
            //当前线程的前指针指向队列的Tail节点
            node.prev = pred;
              //CAS设置当前队列的Tail节点为当前线程节点
            if (compareAndSetTail(pred, node)) {
                //设置上一个Tail节点的后指针指向当前线程节点
                pred.next = node;
                return node;
            }
        }
       //初始化AQS队列,初始化完成之后放入队列
        enq(node);
        return node;
    }
//=========================enq初始化AQS方法=============
   private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                //CAS初始化队列的Head  Tail 节点
                if (compareAndSetHead(new Node()))
                    tail = head;
            } 
 //初始化队列之后，将当前线程的节点，放入队列的第二个元素，第一个元素的Thread永远为null
            else {
                //当前线程的前指针指向队列的Tail节点
                node.prev = t;
                //CAS设置当前队列的Tail节点为当前线程节点
                if (compareAndSetTail(t, node)) {
                    //设置上一个Tail节点的后指针指向当前线程节点
                    t.next = node;
                    return t;
                }
            }
        }
    }
```

 

4.在放入队列成功之后 调用acquiredQueue方法

```java 
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            //获取当前线程的前节点
            final Node p = node.predecessor();
            //如果当前线程的前节点是Head的话，
            //且能获取锁 ，那么清除当前线程节点的线程。设置为Head节点，断开前Head的指向
            //方便GC回收前Head节点对象
            //此处是第一次开始自旋尝试获取锁的过程
            //如果shouldParkAfterFailedAcquire返回false的话即:前置节点的waitstatus已被置为-1，会开始第二次自选尝试获得锁
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            //传入当前线程节点的前一节点以及当前线程节点
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

5.如果放入队列成功，并且第一次自旋获取锁失败的话，进入shouldParkAfterFailedAcquire（）方法,

1. 此方法中会判断线程节点的waitstatus.第一次进入必定不为-1，因此就会将当前线程节点的前置节点的waitstatus设为-1.开始第二次自旋获得锁的过程。

2. 第二次自旋仍然没有获得锁之后，那么shouldParkAfterFailedAcquire会返回true,进入后面的parkAndCheckInterrupt()方法

```java 
  private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
      //Node节点初始化时它的waitStatus为0
      //当进入的线程节点第一次自旋设置完前置节点的waitstatus之后，再次进入的话会返回true
      int ws = pred.waitStatus;
       //线程节点第一次进入的话waitstatus为0，必定不满足
        if (ws == Node.SIGNAL)
            /*
             * This node has already set status asking a release
             * to signal it, so it can safely park.
             */
            return true;
        if (ws > 0) {
            /*
             * Predecessor was cancelled. Skip over predecessors and
             * indicate retry.
             */
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0);
            pred.next = node;
             //线程节点第一次进入的话waitstatus为0，必定不满足，进入此代码 
        } else {
            /*
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don't park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             */
            //设置当前线程节点的前置节点的waitstatus为-1
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
```



6. 第二次自旋仍然没有获得锁之后 parkAndCheckInterrupt（）方法

	```java 
	  private final boolean parkAndCheckInterrupt() {
	      //让进入此方法当前线程进入睡眠状态
	        LockSupport.park(this);
	      //恢复线程中断的标志位
	        return Thread.interrupted();
	    }
	
	```

	





7. unlock()方法

	 1. tryrelease方法会会释放锁，直到将state减至0
	
	2. 当锁状态被清空至0后，会将当前线程节点的waitstatus恢复至0，并且unpark队列的下一线程节点

	```java 
	    public void unlock() {
	        sync.release(1);
	    }
	//======================================
	 public final boolean release(int arg) {
	     //如果成功释放锁的话，后续唤醒队列中的线程，并且还原当前线程节点的waitstatus
	        if (tryRelease(arg)) {
	            Node h = head;
	            if (h != null && h.waitStatus != 0)
	                //unpark方法唤醒队列中正在等待的线程节点
	                unparkSuccessor(h);
	            return true;
	        }
	        return false;
	    }
	//=================================
	     protected final boolean tryRelease(int releases) {
	         //当前state 减1
	            int c = getState() - releases;
	         //如果当前线程不是持有锁的线程抛出异常
	            if (Thread.currentThread() != getExclusiveOwnerThread())
	                throw new IllegalMonitorStateException();
	            boolean free = false;
	         //如果state已经置为0，代表可重入次数state置为了0
	            if (c == 0) {
	                free = true;
	                setExclusiveOwnerThread(null);
	            }
	         //重新设置state值
	            setState(c);
	            return free;
	        }
	//===================================================================
	 private void unparkSuccessor(Node node) {
	        /*
	         * If status is negative (i.e., possibly needing signal) try
	         * to clear in anticipation of signalling.  It is OK if this
	         * fails or if status is changed by waiting thread.
	         */
	        int ws = node.waitStatus;
	        if (ws < 0)
	            compareAndSetWaitStatus(node, ws, 0);
	
	        /*
	         * Thread to unpark is held in successor, which is normally
	         * just the next node.  But if cancelled or apparently null,
	         * traverse backwards from tail to find the actual
	         * non-cancelled successor.
	         */
	        Node s = node.next;
	        if (s == null || s.waitStatus > 0) {
	            s = null;
	            for (Node t = tail; t != null && t != node; t = t.prev)
	                if (t.waitStatus <= 0)
	                    s = t;
	        }
	    if (s != null)
	            //如果队列中有下一节点的话，唤醒下一个线程
	            LockSupport.unpark(s.thread);
	    }
	```


​	







## 5.ThreadLocal源码

1.new ThreadLocal()

2.threadLocal.set(Object)方法

判断currentThread.threadLocalMap 是否为null 如果为Null初始化一个，如果不为null直接set

```java 
   public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }
```



3.初始化ThreadLocal方法,并且放入元素

```java 
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
//============================================================
//初始化entry数组
table = new Entry[INITIAL_CAPACITY];
//计算当前ThreadlOCAL对象的hashCode值 注意这里的entry为weakReference
int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
//给Hash表填充元素
table[i] = new Entry(firstKey, firstValue);
size = 1;
setThreshold(INITIAL_CAPACITY);
```

4.给已有的ThreadLocalMap赋值

```java 
private void set(ThreadLocal<?> key, Object value) {
    // We don't use a fast path as with get() because it is at
    // least as common to use set() to create new entries as
    // it is to replace existing ones, in which case, a fast
    // path would fail more often than not.

    Entry[] tab = table;
    int len = tab.length;
    //计算当前ThreadlOCAL对象的hashCode值
    int i = key.threadLocalHashCode & (len-1);

    //如果当前hash表有值，则取下一个，不断循环，直至位置为null
    for (Entry e = tab[i];
         e != null;
         e = tab[i = nextIndex(i, len)]) {
        ThreadLocal<?> k = e.get();
        //如果hash冲突数组当中刚好key一样，新值替换旧值
        if (k == key) {
            e.value = value;
            return;
        }
        //如果hash不冲突 设置值 ，涉及到垃圾回收
        if (k == null) {
            replaceStaleEntry(key, value, i);
            return;
        }
    }
    //如果key不一样发生hash冲突
    tab[i] = new Entry(key, value);
    int sz = ++size;
    //如果数组已满，扩容成新数组
    if (!cleanSomeSlots(i, sz) && sz >= threshold)
        rehash();
}
```

5.entry[]数组的扩容

```java 
   private void rehash() {
            expungeStaleEntries();

            // Use lower threshold for doubling to avoid hysteresis
       //用到数组容量的0.75倍时扩容
            if (size >= threshold - threshold / 4)
                resize();
        }
//====================================================================
 private void resize() {
            Entry[] oldTab = table;
            int oldLen = oldTab.length;
            int newLen = oldLen * 2;
            Entry[] newTab = new Entry[newLen];
            int count = 0;

            for (int j = 0; j < oldLen; ++j) {
                Entry e = oldTab[j];
                if (e != null) {
                    ThreadLocal<?> k = e.get();
                    if (k == null) {
                        e.value = null; // Help the GC
                    } else {
                        int h = k.threadLocalHashCode & (newLen - 1);
                        while (newTab[h] != null)
                            h = nextIndex(h, newLen);
                        newTab[h] = e;
                        count++;
                    }
                }
            }

            setThreshold(newLen);
            size = count;
            table = newTab;
        }

```

  6.get()方法  直接返回当前线程 threadLocalMap的 entry对象,不存在自动初始化

```java 
 public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }
```





## 6.JAVA System.getEnv System.getProperties  System.getProperty的区别

1. 如果配置属性才能让System.getProperty(String)获取到?
	使用java -D 配置系统属性.使用格式是:java -Dkey=value,如果value中有空格,则需要用双引号将该值括起来，如：-Dname="kazaf f"

2. Systm.getenv()和System.getProperties()有何区别呢?
	System.getenv()是获取系统环境变量，System.getProperties()是获取当前系统相关属性信息。 
	System.getenv():返回当前系统环境的字符串Map,其是不可变的,环境变量是系统相关的键值对,从父进程传递到子进程.如:JAVA_HOME,PATH等 
	System.getProperties():获取系统相关属性，比如：Java版本、操作系统信息、用户名等，这些跟JVM和操作系统相关的属性.如:java.version,os.name,user.dir,file.separator等



## 7.Samaphore-AQS源码分析

#### 1.new  Samaphore(int permits)

创建了继承了Syn----->AQS的FairSyn或者NoFairSyn对象。并且对象的State的值为permits

```java 
//==========Semaphore======================================================== 
public Semaphore(int permits) {
    sync = new NonfairSync(permits);
}
//=================Semaphore.Sync.FairSync======================
NonfairSync(int permits) {
    super(permits);
}
//================Semaphore.Sync==================================
Sync(int permits) {
    setState(permits);
}
//==================AbstractSynchronizedQueue======================
protected final void setState(int newState) {
    state = newState;
}
```





#### 2.Samaphore.acquire()方法

1. Syn的acquireSharedInterruptibly(int args)方法实际上是AQS的方法

	如果当前线程Thread.interrupted为true的话，那么直接抛出异常。

	如果为false的话，执行AQS的tryAcquireShared(1)方法

```java 
//===========================Semaphore============================================  
public void acquire() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }
//===========================AbstractSynchronizedQueue============================
   public final void acquireSharedInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        if (tryAcquireShared(arg) < 0)
            doAcquireSharedInterruptibly(arg);
    }
//=======================================================================
    private void doAcquireSharedInterruptibly(int arg)
        throws InterruptedException {
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head) {
                    int r = tryAcquireShared(arg);
                    if (r >= 0) {
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        failed = false;
                        return;
                    }
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```







#### 3.AQS的tryAcquireShared(int args)方法

tryAcquireShared方法会无限循环。直至hasQueuedProecessor返回true.或者 avaible-1之后小于0或者cas操作 avaiable成功。返回小于0的话代表，共享资源state已被耗尽。后续线程需要被加入队列。

```java 
//====================AbstaractSynchronizedQueue=====================================
 protected int tryAcquireShared(int acquires) {
            for (;;) {
                if (hasQueuedPredecessors())
                    return -1;
                int available = getState();
                int remaining = available - acquires;
                if (remaining < 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }
    }
```



#### 4.AQS的doAcquireSharedInterruptibly方法

首先放入队列，并且入队节点是Node.SHARED模式，循环，每次获取构建节点的前置节点。判断是否是队列的head节点。如果不是的话，进入AQS的shouldParkAfterFaILedAcquire方法，此方法和ReenTrantLock的方法一样。就是判断前置节点的状态是否为-1，如果不为-1的话设置为-1 返回false进行下一次循环。下一次循环如果还是不是head并且获取共享资源失败的话，那么再次进入shouldParkAfterFaILedAcquire方法。因为前置节点已被设置为-1，代表前置节点的next节点需要被阻塞的状态。那么接下来进入parkAndCheckInterrupt方法。LockSupport.park()方法阻塞此线程。



如果当前节点以为头部节点并且获取共享资源成功的话，那么就会CAS设置head节点，并且会进行节点的传播行为

```java 
//====================AbstaractSynchronizedQueue===================================== 
private void doAcquireSharedInterruptibly(int arg)
        throws InterruptedException {
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head) {
                    int r = tryAcquireShared(arg);
                    if (r >= 0) {
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        failed = false;
                        return;
                    }
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```





#### 5.AQS的setHeadAndPropagate方法

1. **如果在当前线程消耗共享资源之后，仍然有可用的共享资源，那么当前线程不仅要自己占用锁，还要唤醒队列中其他可以占用锁资源的线程。**
2. **还有一个重要作用是配合tryReleased的方法解决一个BUG：当一个线程刚执行完compareAndSetWaitStatus(h, Node.SIGNAL, 0)方法，另一个线程因为head.waitstatus=0,而没有满足head.waitstatus=-1的判断 ，那么此时doReleasedShared方法不会进行unpark线程，这里做了一个优化，当head.waitstaus=0的话会compareAndSetWaitStatus(h, 0, Node.PROPAGATE)， 那么即使release方法没有唤醒后续节点。在后续节点的acquire方法的setHeadProagate方法中仍然可以通过判断h.waitstatus=0,来之前漏唤醒的线程唤醒**

```java 
//====================AbstaractSynchronizedQueue=====================================  
private void setHeadAndPropagate(Node node, int propagate) {
        Node h = head; // Record old head for check below
        setHead(node);
        /*
         * Try to signal next queued node if:
         *   Propagation was indicated by caller,
         *     or was recorded (as h.waitStatus either before
         *     or after setHead) by a previous operation
         *     (note: this uses sign-check of waitStatus because
         *      PROPAGATE status may transition to SIGNAL.)
         * and
         *   The next node is waiting in shared mode,
         *     or we don't know, because it appears null
         *
         * The conservatism in both of these checks may cause
         * unnecessary wake-ups, but only when there are multiple
         * racing acquires/releases, so most need signals now or soon
         * anyway.
         */
        if (propagate > 0 || h == null || h.waitStatus < 0 ||
            (h = head) == null || h.waitStatus < 0) {
            Node s = node.next;
            if (s == null || s.isShared())
                doReleaseShared();
        }
    }
```





#### 6.Samaphore的release()方法

实际调用sync的release方法，实际就是AQS的releaseShared方法



#### 7.AQS的releasedShared方法

tryReleaseShared尝试释放

```java 
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }
```



#### 8.Semaphore的tryReleaseShared方法

cas 改变AQS的state方法，

```java 
       protected final boolean tryReleaseShared(int releases) {
            for (;;) {
                int current = getState();
                int next = current + releases;
                if (next < current) // overflow
                    throw new Error("Maximum permit count exceeded");
                if (compareAndSetState(current, next))
                    return true;
            }
        }
```

#### 9.AQS的doReleaseShared()方法

循环获取head节点

如果队列当中包含一个入队节点的时候，如果head的状态Node.SIGNAL -1为阻塞，说明，head的下一节点需要唤醒。调用unparkSuccessor(h) LockSupport.unpark，head节点所在的线程



如果为0说明后置节点可能需要被唤醒（在shouldParkAfterFailedAcquire中尚未来的及把前置节点的waitstatus设置为-1），也可能根本不存在，所以设置为Node.Proagate.以便 在被唤醒



如果head发生改变则说明Head节点发生改变，所以重新开始唤醒。

```java 
  for (;;) {
            Node h = head;
            if (h != null && h != tail) {
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue;            // loop to recheck cases
                    unparkSuccessor(h);
                }
                else if (ws == 0 &&
                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue;                // loop on failed CAS
            }
            if (h == head)                   // loop if head changed
                break;
        }
```





## 8.AQS  Condition 的await()   signal方法

#### 1.new Condition()

实际创建的是AQS的ConditionObject对象，此对象实现了Condition接口

```java 
//=========================ReenTrantLock====================================
public Condition newCondition() {
    return sync.newCondition();
}

//===============AbstractSynchronizedQueue================================= 
final ConditionObject newCondition() {
    return new ConditionObject();
}
```

#### 2.ConditionObject的await()方法

```java 
//=====================AbstractSynchoronizedQUeue===============
public final void await() throws InterruptedException {
            if (Thread.interrupted())
                throw new InterruptedException();
            Node node = addConditionWaiter();
            int savedState = fullyRelease(node);
            int interruptMode = 0;
            while (!isOnSyncQueue(node)) {
                LockSupport.park(this);
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
            if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            if (node.nextWaiter != null) // clean up if cancelled
                unlinkCancelledWaiters();
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
        }
```

1. addConditionWaiter方法 先把条件队列中waitstatus不为Node.Condition(-2)的节点踢出队列。之后将新的节点重新串联至旧有队列。

	```java 
	        private Node addConditionWaiter() {
	            Node t = lastWaiter;
	            // If lastWaiter is cancelled, clean out.
	            if (t != null && t.waitStatus != Node.CONDITION) {
	                unlinkCancelledWaiters();
	                t = lastWaiter;
	            }
	            Node node = new Node(Thread.currentThread(), Node.CONDITION);
	            if (t == null)
	                firstWaiter = node;
	            else
	                t.nextWaiter = node;
	            lastWaiter = node;
	            return node;
	        }
	```

	

2. fullyRelease方法 尝试释放锁资源state ,返回释放之前的锁资源state，并且唤醒下一个节点。

	```java 
	    final int fullyRelease(Node node) {
	        boolean failed = true;
	        try {
	            int savedState = getState();
	            if (release(savedState)) {
	                failed = false;
	                return savedState;
	            } else {
	                throw new IllegalMonitorStateException();
	            }
	        } finally {
	            if (failed)
	                node.waitStatus = Node.CANCELLED;
	        }
	    }
	```

	

3. while(!isOnSynQueue(node))  判断节点是否在队列的等待节点中

	 a,node.waitstatus 为Node.Condition状态 node必定在条件队列中

	 b,node.prev=null 队列尚在初始化，或者此节点已获得锁。

	这种返回false 会执行LockSupportPark方法 睡眠线程.

	c,满足上述a,b条件之后，node.next!=null 必定处于队列的等待节点中，返回true ,跳出循环

	d,满足上述a,b,c条件之后findFromTail(node)  此种只能是一种正在加入等待队列的状态，就是刚把自己设置为Tail但是尚未设置自己的next节点。

	```java 
	    final boolean isOnSyncQueue(Node node) {
	        if (node.waitStatus == Node.CONDITION || node.prev == null)
	            return false;
	        if (node.next != null) // If has successor, it must be on queue
	            return true;
	        /*
	         * node.prev can be non-null, but not yet on queue because
	         * the CAS to place it on queue can fail. So we have to
	         * traverse from tail to make sure it actually made it.  It
	         * will always be near the tail in calls to this method, and
	         * unless the CAS failed (which is unlikely), it will be
	         * there, so we hardly ever traverse much.
	         */
	        return findNodeFromTail(node);
	    }
	```

	

4. 返回false之后不在等待队列的状态，直接LockSupport.park()

5. checkInterruptWhileWaiting(Node node) 检车睡眠线程signal之前，signal之后是否被中断过。

	1. 如果没有被打断直接返回0
	2. 如果被打断过，判断中断时间点  依据：
		1. 如果CAS 此节点的状态Node.COndition------>0 成功的话，说明被中断。因为signal方法会将节点的waitstatus状态由Node.Condition------>0。将条件队列节点 重新加入同步队列当中去。
		2. 如果CAS失败 说明判断是否再同步队列中等待，如果不在的话不断Thread.yield()让渡CPU执行优先权。直至加入同步队列。

	```java 
	  private int checkInterruptWhileWaiting(Node node) {
	            return Thread.interrupted() ?
	                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
	                0;
	        }
	//=================AbstractSynchroizedQueue==================================
	    final boolean transferAfterCancelledWait(Node node) {
	        if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
	            enq(node);
	            return true;
	        }
	        /*
	         * If we lost out to a signal(), then we can't proceed
	         * until it finishes its enq().  Cancelling during an
	         * incomplete transfer is both rare and transient, so just
	         * spin.
	         */
	        while (!isOnSyncQueue(node))
	            Thread.yield();
	        return false;
	    }
	```

	

6.  被signal的线程尝试获取锁，如果获取锁成功，并且不是signal方法执行之前打断的话，设置REINTERRUPT标记

	```java 
	  if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
	                interruptMode = REINTERRUPT;
	```

	

7. 如果node有后续nextWaiter节点时，剔除节点状态不为Node.condition状态的节点。

8. 如果interrupteMode为1的话执行reportInterruptAfterWait方法，此方法 THROW_IE直接抛出异常，REINTERRUPT的话selfInterrupt 恢复用户线程的打断状态

```java 
 private void reportInterruptAfterWait(int interruptMode)
            throws InterruptedException {
            if (interruptMode == THROW_IE)
                throw new InterruptedException();
            else if (interruptMode == REINTERRUPT)
                selfInterrupt();
        }
```







#### 2.ConditionObject的Signal方法

1. signal方法 isHeldExclusively判断执行signal方法的线程是否是持有锁的线程。不是的话抛出异常，是的话获取条件队列中的Head节点。如果不为null的话doSignal方法
2. 获取条件等待队列的第一个节点，如果不为null的话，执行doSignal方法

```java 
//=====================AbstractSynchronizedQueue========================= 
public final void signal() {
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            Node first = firstWaiter;
            if (first != null)
                doSignal(first);
        }
```



3. doSignal方法中一个do while循环。  如果为等待队列的最后一个节点，设置lasWaiter为null,

	如果断掉条件队列中的此节点。

```java 
//=====================AbstractSynchronizedQueue=========================  
private void doSignal(Node first) {
            do {
                if ( (firstWaiter = first.nextWaiter) == null)
                    lastWaiter = null;
                first.nextWaiter = null;
            } while (!transferForSignal(first) &&
                     (first = firstWaiter) != null);
        }
```



4. transferForSignal方法 如果cas 条件队列中的节点Node.Condition到0成功的话，继续往下走，否则返回false继续循环CAS

CAS成功的话，把此条件队列的节点CAS加入同步等待队列中。返回的是此节点的前驱节点，获取前驱节点的waitstatus,如果状态大于0或者cas 此节点状态为Node.SIGNAL失败的话 LockSupport.unpark此节点。返回true.

```java 
 final boolean transferForSignal(Node node) {
        /*
         * If cannot change waitStatus, the node has been cancelled.
         */
        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
            return false;

        /*
         * Splice onto queue and try to set waitStatus of predecessor to
         * indicate that thread is (probably) waiting. If cancelled or
         * attempt to set waitStatus fails, wake up to resync (in which
         * case the waitStatus can be transiently and harmlessly wrong).
         */
        Node p = enq(node);
        int ws = p.waitStatus;
        if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
            LockSupport.unpark(node.thread);
        return true;
    }
```





## 9.AQS  CountDownLatch 源码

#### 1.new CountDownLatch(int count)

创建内部类syn也是继承AQS.  设置state的值为 count

```java 
 public CountDownLatch(int count) {
        if (count < 0) throw new IllegalArgumentException("count < 0");
        this.sync = new Sync(count);
    }
//=======================================================================================
Sync(int count) {
            setState(count);
        }
```



#### 2.await 方法

就是调用AQS的acquireSharedInterruptibly方法，传入1,其中 tryAcquireShared是自身的重写。doAcquireSHaredInterruptity是AQS的逻辑

```java 
  public void await() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }
//==========================================================
    public final void acquireSharedInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        if (tryAcquireShared(arg) < 0)
            doAcquireSharedInterruptibly(arg);
    }
```





CountDownLatch  Syn自身的实现 如果state为0  返回1  否则返回-1。配合上面就知道。如果state为0的话，调用await方法的线程才会继续往下执行逻辑。否则的话进入doAcquireSharedInterruptibly(1) 方法。会尝试获取锁。因为tryAcquire已被重写。所以再state不为0的情况，此线程始终获取不到锁。因此会进入等待队列，等到被唤醒。

```java 
 protected int tryAcquireShared(int acquires) {
            return (getState() == 0) ? 1 : -1;
        }
```



#### 3.countDown()方法

这里tryReleaseShared方法是自身实现。doReleaseShared方法也是AQS的父类方法。

```java 
   public void countDown() {
        sync.releaseShared(1);
    }
//============================================================================
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }
```



tryReleaseShared方法  如果c等于0了返回false 否则CAS  如果CAS之后state变为0返回true .否则返回false.

因此，只有将state改为0的线程，可以进入doReleasedShared方法，唤醒睡眠的线程。

```java 
 protected boolean tryReleaseShared(int releases) {
            // Decrement count; signal when transition to zero
            for (;;) {
                int c = getState();
                if (c == 0)
                    return false;
                int nextc = c-1;
                if (compareAndSetState(c, nextc))
                    return nextc == 0;
            }
        }
```







## Thread  interrupt()  isInterrupted()   interrupted

1. interrupte 线程对象的实例方法  讲线程的中断状态显示为true.
2. isInterrupted()如果线程被interrupt为true.没有被interrupt为false.显示线程中断状态
3. interrupted  恢复线程的中断状态。如果isInterrupted为true,调用此方法，可以之后返回false



